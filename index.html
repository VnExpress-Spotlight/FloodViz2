<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bảng điều khiển mưa & mực nước - Scrollytelling</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@9.1.0/ol.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; background: #1a1a1a; color: #e5e5e5; overflow: hidden; }
        
        /* --- Map & Layout --- */
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1; background: #222; }

        /* --- Custom Slider Styling --- */
        .range-container { position: relative; width: 100%; height: 20px; display: flex; align-items: center; }
        .range-track { position: absolute; top: 50%; transform: translateY(-50%); left: 0; width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; z-index: 1; }
        .range-fill { position: absolute; top: 50%; transform: translateY(-50%); height: 4px; background: #3b82f6; z-index: 2; pointer-events: none; }
        
        input[type=range] { -webkit-appearance: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: transparent; pointer-events: none; z-index: 5; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; pointer-events: auto; height: 18px; width: 18px; border-radius: 50%; cursor: pointer; margin-top: 1px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        input[type=range]:focus { outline: none; }
        
        #slider-start::-webkit-slider-thumb { background: #9ca3af; border: 2px solid #fff; z-index: 4; }
        #slider-end::-webkit-slider-thumb { background: #fbbf24; border: 2px solid #fff; z-index: 6; width: 20px; height: 20px; }
        /* Reset styling for UI range sliders in panels */
        #opacity-rain, #opacity-hydro { 
            position: static; pointer-events: auto; z-index: 1; height: 6px; 
            background: linear-gradient(to right, #0ea5e9, #1d4ed8); 
            border-radius: 9999px;
        }
        #opacity-rain::-webkit-slider-thumb, #opacity-hydro::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: #f59e0b;
            border: 2px solid #0f172a;
            width: 16px; height: 16px; border-radius: 50%;
            box-shadow: 0 0 6px rgba(245, 158, 11, 0.7);
            cursor: pointer;
        }
        #opacity-rain::-moz-range-thumb, #opacity-hydro::-moz-range-thumb {
            background: #f59e0b;
            border: 2px solid #0f172a;
            width: 16px; height: 16px; border-radius: 50%;
            box-shadow: 0 0 6px rgba(245, 158, 11, 0.7);
            cursor: pointer;
        }

        /* --- UI Components --- */
        .glass-panel { background: rgba(30, 30, 30, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); }
        
        /* --- Leaflet/OL Customization --- */
        .leaflet-bar a { background-color: #333; color: #fff; border-bottom: 1px solid #444; }
        .leaflet-bar a:hover { background-color: #444; }
        .leaflet-container { background: #111; }
        .leaflet-popup-content-wrapper { background: rgba(30, 30, 30, 0.95); color: white; border-radius: 8px; backdrop-filter: blur(4px); }
        .leaflet-popup-tip { background: rgba(30, 30, 30, 0.95); }
        
        .custom-tooltip { background: rgba(0,0,0,0.9); border: 1px solid #444; color: white; font-size: 12px; border-radius: 4px; padding: 6px 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .leaflet-tooltip-top:before { border-top-color: rgba(0,0,0,0.9); }

        /* --- D3 Chart Styling --- */
        #chart-container { position: relative; height: 100px; width: 100%; margin-bottom: 0px; }
        .chart-area { fill: url(#chartGradient); opacity: 0.6; stroke: #60a5fa; stroke-width: 1.5px; }
        .chart-selection-rect { fill: #3b82f6; opacity: 0.2; }
        .chart-cursor { stroke: #fbbf24; stroke-width: 2px; stroke-dasharray: 4 2; opacity: 0.8; }
        
        .popup-chart path { fill: #60a5fa; fill-opacity: 0.3; stroke: #60a5fa; stroke-width: 2px; }
        .popup-chart .domain, .popup-chart .tick line { stroke: #555; }
        .popup-chart .tick text { fill: #999; font-size: 9px; }
        .popup-cursor-line { stroke: #fbbf24; stroke-width: 1.5px; stroke-dasharray: 3 2; opacity: 1; transition: x1 0.05s linear, x2 0.05s linear; }
        
        /* --- Marker Animation --- */
        .station-marker { transition: all 0.3s ease; box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
        .map-tooltip { 
            pointer-events: none;
            white-space: nowrap;
            font-size: 11px;
            background: rgba(15,23,42,0.95);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            padding: 4px 8px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        .map-tooltip .label { font-weight: 600; color: #fff; font-size: 12px; }
        .map-tooltip .value { color: #d1d5db; }
        .chart-tooltip {
            position: absolute;
            background: rgba(15,23,42,0.95);
            border: 1px solid rgba(255,255,255,0.1);
            color: #e5e7eb;
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 10;
            white-space: nowrap;
        }
        .chart-tooltip.visible { opacity: 1; }

        #story-label {
            text-shadow: 0 1px 4px rgba(0,0,0,0.7);
            font-size: 1.1rem;
            padding: 6px 12px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 8px;
        }
        .current-time-label { font-weight: 800; }

        /* SCROLLYTELLING STYLES */
        #story-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100vh;
            width: 100%;
            z-index: 50;
            overflow-y: auto;
            padding-bottom: 50vh; /* Allow scrolling past last element */
            scroll-behavior: smooth;
        }
        /* Hide scrollbar for cleaner look */
        #story-container::-webkit-scrollbar { width: 0px; background: transparent; }
        
        .step {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            pointer-events: none; /* Let clicks pass through the spacer areas */
            opacity: 0.3;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: scale(0.95);
        }
        .step.active {
            opacity: 1;
            transform: scale(1);
        }
        .step-inner-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* 24px */
            width: 100%;
        }
        .step-content {
            pointer-events: auto; /* Enable interaction with text box */
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 22px; 
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-left: 4px solid #3b82f6;
            width: 100%;
            max-width: 560px; /* Increased from 480px */
        }
        .step-pinned-charts {
            display: flex;
            flex-direction: column;
            gap: 1rem; /* 16px */
            width: 100%;
            max-width: 520px; /* Slightly narrower than text */
            pointer-events: auto;
        }
        #desktop-pinned-charts {
            display: none;
            position: fixed;
            top: 50%;
            right: 32px;
            transform: translateY(-50%);
            width: 320px;
            max-width: 32vw;
            z-index: 60;
        }
        @media (min-width: 1024px) {
            #story-container { padding-right: 360px; }
            .step-inner-wrapper {
                flex-direction: row;
                align-items: flex-start;
                justify-content: flex-start;
                max-width: 1200px;
                margin-left: clamp(12px, 2vw, 40px);
                margin-right: auto;
            }
            .step-content {
                max-width: none;
                width: 60%;
            }
            .step-pinned-charts {
                width: 40%;
            }
            #desktop-pinned-charts {
                display: flex;
            }
            .step-pinned-charts:not(#desktop-pinned-charts) {
                display: none;
            }
        }
        @media (max-width: 640px) {
            .step-inner-wrapper { gap: 0.75rem; align-items: stretch; }
            .step-content { width: 100%; }
            .step-pinned-charts { margin-top: 0; }
        }
        
        .step-content p {
            /* UPDATED: Increased font size for readability */
            font-size: 1.1rem;
        }

        /* Timeline bar visible again */
        .timeline-wrapper { display: flex; height: auto; min-height: 0; align-items: flex-end; }
        .timeline-wrapper.show-mobile-pins { display: flex; height: auto; min-height: 0; align-items: flex-end; padding-top: 1rem; }
        #mobile-pinned-preview .mobile-pin-card {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 8px 24px rgba(0,0,0,0.45);
        }
        #mobile-pinned-preview .mobile-pin-title { font-weight: 700; }
        #mobile-pinned-preview .mobile-pin-sub { font-size: 12px; color: #9ca3af; }
        #mobile-pinned-preview .mobile-pin-badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 9999px;
            font-weight: 700;
            border: 1px solid rgba(255,255,255,0.12);
        }
        #mobile-pinned-preview { max-height: 55vh; overflow-y: auto; }

        @media (max-width: 640px) {
            #story-container {
                height: 100vh; /* Takes full screen on mobile */
                bottom: auto;
            }
            .timeline-wrapper { height: 120px; padding-bottom: 0.75rem; padding-top: 0.25rem; }
            #mobile-pinned-preview { max-height: 45vh; }
            .step-content h3 {
                font-size: 1.25rem; /* text-xl */
            }
            .step-content p {
                font-size: 0.95rem;
                line-height: 1.5;
            }
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="story-container">
        <div style="height: 30vh;"></div>

        <div class="step" data-step="1">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">“Lá chắn” cuối cùng</h3>
                    <p class="leading-relaxed text-gray-200">
                        Hồ Sông Ba Hạ là chốt chặn cuối cùng của hệ thống bậc thang sông Ba. Dung tích phòng lũ đạt 125 triệu m3, chiếm 1/3 tổng dung tích hồ chứa.
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>

        <div class="step" data-step="2">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">Xả nước đón lũ</h3>
                    <p class="leading-relaxed text-gray-200">
                        28 tiếng trước đợt mưa lớn (20h ngày 14/11), hồ chủ động xả nước hạ thấp mực hồ (lượng xả > về) theo lệnh vận hành của UBND tỉnh Đăk Lăk.
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>
        
        <div class="step" data-step="3">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">Vận hành duy trì</h3>
                    <p class="leading-relaxed text-gray-200">
                        10h ngày 16/11, khi mực nước tại hồ giảm xuống mực nước đón lũ lớn nhất theo quy định sau ngày 15/11 (103 m), hồ chuyển sang vận hành duy trì với lưu lượng xả xấp xỉ lượng nước về hồ.
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>

        <div class="step" data-step="4">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">“Cắt lũ” lần đầu</h3>
                    <p class="leading-relaxed text-gray-200">
                        19h ngày 18/11, “tâm mưa” bắt đầu dịch chuyển dần về Đăk Lăk. Mực nước tại trạm Củng Sơn lên báo động 3. Theo quy định, hồ chuyển sang vận hành giảm lũ (lượng xả < đến), kéo dài liên tục 12 giờ.
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>

        <div class="step" data-step="5">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">Xả lũ lịch sử</h3>
                    <p class="leading-relaxed text-gray-200">
                        Hồ đầy lúc 9h ngày 19/11 khiến việc cắt lũ chấm dứt. Lưu lượng xả tăng dần và lập đỉnh 16.100 m3/s vào 17h, phá vỡ kỷ lục năm 2009. Trước đó một giờ, mực nước tại trạm Củng Sơn ở hạ nguồn sông Ba vượt lịch sử 1993.
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>

        <div class="step" data-step="6">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">"Cắt lũ" lần hai</h3>
                    <p class="leading-relaxed text-gray-200">
                        Khi nhận lệnh của Chủ tịch UBND tỉnh chiều cùng ngày, hồ giảm xả và sử dụng dung tích bảo vệ công trình để “cắt lũ” lần hai cho hạ du từ 20h ngày 19/11, duy trì đến 19h ngày 20/11 thì chuyển sang vận hành duy trì (lượng đến = xả).
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>

        <div class="step" data-step="7">
            <div class="step-inner-wrapper">
                <div class="step-content">
                    <h3 class="text-2xl font-bold text-blue-500 mb-4">Lũ lịch sử</h3>
                    <p class="leading-relaxed text-gray-200">
                        1 giờ ngày 20/11, mực nước tại trạm Củng Sơn ở hạ nguồn sông Ba đạt đỉnh 40,99 m, vượt lịch sử 1993 là 1,09 m. Hai giờ sau, mực nước tại trạm Phú Lâm cũng xác lập kỷ lục mới trong 32 năm với mực nước 5,4 m, cao hơn lũ lịch sử 1993 là 0,19 m. Toàn tỉnh Phú Yên cũ - hạ lưu sông Ba - chìm trong biển nước.
                    </p>
                </div>
                <div class="step-pinned-charts"></div>
            </div>
        </div>


        <div style="height: 50vh;"></div>
    </div>

    <div id="desktop-pinned-charts" class="step-pinned-charts"></div>

    <!-- The #pinned-panel is no longer needed for desktop view -->
    <div class="hidden" id="pinned-panel">
        <button id="layer-toggle-btn"></button>
        <button id="legend-toggle-btn-hidden"></button>
        <button id="filter-toggle-btn"></button>
        <div id="filter-panel"><div id="filter-province-list"></div><div id="filter-river-list"></div></div>
        <div id="layer-panel"></div>
        <div id="pinned-list"></div>
    </div>

    <!-- Floating Legend Toggle -->
    <div class="fixed top-4 right-4 z-[70] flex gap-2 pointer-events-auto">
        <button id="legend-toggle-btn" class="glass-panel px-3 py-2 rounded-lg border border-white/15 text-xs font-semibold uppercase tracking-wide text-white bg-black/60 hover:bg-white/10 transition">
            Chú giải
        </button>
    </div>

    <div id="legend-panel" class="glass-panel px-4 py-3 rounded-lg shadow-2xl w-64 absolute top-14 right-4 z-[80]">
        <!-- Rainfall Legend -->
        <div class="flex justify-between items-start mb-2">
            <div class="text-sm font-semibold text-white">Chú giải</div>
            <button id="legend-close-btn" class="text-gray-300 hover:text-white text-sm">✕</button>
        </div>
        <div id="legend-rain" class="mb-3">
            <div class="flex items-center justify-between mb-2">
                <div class="text-[10px] uppercase tracking-wider text-gray-400">Mưa</div>
                <span id="legend-mode-label" class="text-[11px] text-emerald-300 font-semibold">Theo giờ</span>
            </div>
            <div class="relative h-2 rounded-full mb-1" id="legend-gradient">
                <div id="legend-hover-marker" class="absolute top-1/2 -translate-y-1/2 -translate-x-1/2 w-2 h-2 rounded-full bg-white ring-2 ring-black opacity-0 transition-opacity"></div>
            </div>
            <div class="flex justify-between text-[11px] text-gray-400">
                <span id="legend-min-val">Thấp</span><span id="legend-max-val">Cao</span>
            </div>
        </div>
        <!-- Lake Legend -->
        <div id="legend-lakes" class="mt-3"></div>
        <!-- Station Legend -->
        <div id="legend-stations" class="mt-3"></div>
    </div>

    <div class="absolute bottom-0 left-0 right-0 h-[150px] bg-gradient-to-t from-black via-[#1a1a1a] to-transparent z-30 flex flex-col justify-end pb-4 px-5 pointer-events-none timeline-wrapper">
        <div class="glass-panel w-full rounded-xl p-1 pointer-events-auto flex flex-col gap-1">
            
            <div class="flex items-center justify-between mb-1">
                <div class="flex items-center gap-2">
                    <div class="current-time-wrap">
                        <div class="flex items-baseline gap-2 current-time-values">
                            <div id="display-date" class="text-xl font-bold text-white font-mono">...</div>
                            <div id="start-date-display" class="text-xs text-gray-400 font-mono hidden"></div>
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <div class="text-[10px] text-gray-300 tracking-wider font-semibold timeline-chart-label">Lượng đến / xả Hồ Sông Ba Hạ</div>
                    <div class="flex items-center gap-1 text-[10px]">
                        <span id="lake-ratio-label" class="font-semibold text-white">—</span>
                    </div>
                </div>
            </div>

            <div id="mobile-pinned-preview"></div>

            <div id="chart-container">
                <svg id="timeline-chart" width="100%" height="100%"></svg>
                <div id="chart-legend" class="absolute top-1 right-2 flex items-center gap-2 text-[10px] text-gray-200 bg-black/60 px-2 py-1 rounded-full border border-white/10">
                    <span class="flex items-center gap-1"><span class="inline-block w-2 h-2 rounded-full bg-emerald-400"></span>Đến</span>
                    <span class="flex items-center gap-1"><span class="inline-block w-2 h-2 rounded-full bg-red-500"></span>Xả</span>
                </div>
            </div>

            <div class="range-container">
                <div class="range-track"></div>
                <div class="range-fill" id="range-fill"></div>
                <input type="range" id="slider-start" min="0" max="100" value="0" step="1">
                <input type="range" id="slider-end" min="0" max="100" value="0" step="1">
            </div>
            
            <div class="flex justify-between text-[10px] text-gray-500 font-mono px-1 mt-1" id="timeline-ticks"></div>
        </div>
    </div>

    <input id="toggle-lakes" type="checkbox" class="hidden" checked>
    <input id="toggle-stations" type="checkbox" class="hidden" checked>
    <input id="toggle-rivers" type="checkbox" class="hidden" checked>
    <input id="opacity-rain" type="range" value="75" class="hidden">
    <input id="opacity-hydro" type="range" value="90" class="hidden">

    <script src="https://cdn.jsdelivr.net/npm/ol@9.1.0/dist/ol.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        // =============================================================================
        // 1. CONFIGURATION & CONSTANTS
        // =============================================================================
        const CONFIG = {
            startView: [11.5, 108.5], 
            zoomLevel: 9,
            colors: { low: '#06b6d4', mid: '#22c55e', high: '#ef4444', extreme: '#7f1d1d' }
        };

        // Filter Range Definition
        const FILTER_RANGE = {
            start: new Date("2025-11-14T01:00:00"),
            end: new Date("2025-11-20T20:00:00")
        };
        const COLORS = { blue: '#0ea5e9', green: '#22c55e', yellow: '#fbbf24', red: '#ef4444', purple: '#a855f7' };
        // Edit these bounds to tweak story zooms; values are [minLon, minLat, maxLon, maxLat]
        const STORY_BOUNDS = {
            baBasin: { extentLonLat: [107, 11.6, 109.9, 15] },
            songBaHaTight: { extentLonLat: [108.85, 12.99, 109.05, 13.08] },
            songBaHaArea: { extentLonLat: [108.7, 12.7, 109.35, 13.55] },
            wholeRegion: { extentLonLat: [106.6, 10.6, 110.6, 16.5] }
        };
        
        const MARKER_MAX_RATIO = 150;
        const MARKER_MAX_WARNING = 4;
        const CIRCLE_MARKER_RADIUS = 4;

        const ALLOWED_PROVINCES = [
            "TP Huế", "TP Đà Nẵng", "tỉnh Quảng Nam", "tỉnh Quảng Ngãi",
            "tỉnh Bình Định", "tỉnh Phú Yên", "tỉnh Khánh Hòa", "tỉnh Đắk Lắk", "tỉnh Gia Lai"
        ];

        const isMobileView = () => window.matchMedia('(max-width: 640px)').matches;

        // =============================================================================
        // 2. STATE MANAGEMENT
        // =============================================================================
        let state = {
            // GIS Data
            geoData: null,
            riverData: null,
            stationMeta: {},
            
            dates: [],
            wardIds: [], 
            wardNames: {}, 
            wardProvinces: {},
            
            // Maps for fast lookup
            dataMap: {}, 
            accumulatedMap: {}, 
            waterLevelMap: {}, // { date: { station_id: record } }
            
            wardTimeSeries: {}, 
            timelineStats: [], 
            
            // Time Indices
            startIndex: 0,
            endIndex: 0,
            visibleStartIndex: 0,
            
            isPlaying: false,
            mode: 'accumulated', 
            maxDaily: 60,
            maxTotal: 300
        };

        let layerVisibility = { rain: false, river: true, stations: true, lakes: true }; // Modified default for story
        let layerOpacity = { rain: 0.75, hydro: 0.9 };
        let filters = { provinces: new Set(), rivers: new Set() };
        let rainThresholds = { p50: 0, p90: 0, p99: 0 };
        
        // Runtime Variables
        let pendingUpdate = null;
        let timelinePlayTimer = null;
        let pinnedCharts = [];
        let geoLayer, riverLayer, stationLayer, lakeLayer;
        let chartXScale, chartYScale, timelineBaseIndex = 0;
        const lakeRatioLogs = new Set();
        let popupCursorRegistry = [];
        let currentStoryStep = null;
        let sliderAnimationFrame = null;
        const stepRanges = {};
        let scrollSyncPending = false;
        const stepScrollAnchors = {};
        const registerPopupCursor = (entry) => {
            popupCursorRegistry.push(entry);
            return () => { popupCursorRegistry = popupCursorRegistry.filter(e => e !== entry); };
        };
        const hideCungSonLabel = () => { cungSonLabelOverlay.setPosition(undefined); cungSonLabelElement.classList.add('hidden'); };
        function updatePopupCursorLines() {
            const cursorIdx = Math.max(0, state.endIndex - state.visibleStartIndex);
            popupCursorRegistry = popupCursorRegistry.filter(entry => {
                const node = entry.line.node();
                if (!node || !document.body.contains(node)) return false;
                if (!entry.dates.length) return true;
                const cappedIdx = Math.min(cursorIdx, entry.dates.length - 1);
                const xPos = entry.scale(entry.dates[cappedIdx]);
                if (xPos !== undefined) entry.line.attr("x1", xPos).attr("x2", xPos);

                const startIdx = Math.max(0, Math.min(entry.dates.length - 1, state.startIndex - state.visibleStartIndex));
                const endIdx = Math.max(0, Math.min(entry.dates.length - 1, state.endIndex - state.visibleStartIndex));
                if (entry.rect && entry.rect.node() && document.body.contains(entry.rect.node())) {
                    const xStart = entry.scale(entry.dates[Math.min(startIdx, endIdx)]);
                    const xEnd = entry.scale(entry.dates[Math.max(startIdx, endIdx)]);
                    const width = Math.max(4, Math.abs(xEnd - xStart));
                    entry.rect.attr("x", Math.min(xStart, xEnd)).attr("width", width);
                }
                return true;
            });
        }

        // =============================================================================
        // 3. DOM ELEMENTS CACHE
        // =============================================================================
        const DOM = {
            sliderStart: document.getElementById('slider-start'),
            sliderEnd: document.getElementById('slider-end'),
            rangeFill: document.getElementById('range-fill'),
            chkLakes: document.getElementById('toggle-lakes'),
            chkStations: document.getElementById('toggle-stations'),
            chkRivers: document.getElementById('toggle-rivers'),
            layerPanel: document.getElementById('layer-panel'),
            layerToggleBtn: document.getElementById('layer-toggle-btn'),
            legendToggleBtn: (() => {
                const btns = document.querySelectorAll('#legend-toggle-btn');
                return btns.length ? btns[btns.length - 1] : null;
            })(),
            legendPanel: document.getElementById('legend-panel'),
            legendRain: document.getElementById('legend-rain'),
            legendLakes: document.getElementById('legend-lakes'),
            legendStations: document.getElementById('legend-stations'),
            legendModeLabel: document.getElementById('legend-mode-label'),
            legendGradient: document.getElementById('legend-gradient'),
            legendMinVal: document.getElementById('legend-min-val'),
            legendMaxVal: document.getElementById('legend-max-val'),
            legendCloseBtn: document.getElementById('legend-close-btn'),
            filterToggleBtn: document.getElementById('filter-toggle-btn'),
            filterPanel: document.getElementById('filter-panel'),
            filterProvinceList: document.getElementById('filter-province-list'),
            filterRiverList: document.getElementById('filter-river-list'),
            mobilePinnedPreview: document.getElementById('mobile-pinned-preview'),
            opacityRain: document.getElementById('opacity-rain'),
            opacityHydro: document.getElementById('opacity-hydro'),
        };

        const defaultControls = (ol.control && typeof ol.control.defaults === 'function') 
            ? ol.control.defaults({ attribution: false, zoom: false }) // Remove zoom controls for story mode
            : undefined;
        const map = new ol.Map({
            target: 'map',
            controls: defaultControls,
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://mt0.google.com/vt/lyrs=s&hl=vi&x={x}&y={y}&z={z}'
                    }),
                    zIndex: 100
                }),
                new ol.layer.Tile({
                    source: new ol.source.XYZ({
                        url: 'https://vndms.dmptc.gov.vn/VNDark/{z}/{x}/{y}.png'
                    }),
                    opacity: 0.7,
                    zIndex: 200 // Place labels on top of satellite, but below data
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([CONFIG.startView[1], CONFIG.startView[0]]),
                zoom: CONFIG.zoomLevel,
                minZoom: 5,
                maxZoom: 20
            })
        });

        const popupElement = document.createElement('div');
        popupElement.id = 'ol-popup';
        popupElement.className = 'glass-panel rounded-lg shadow-lg text-white';
        document.body.appendChild(popupElement);
        const popupOverlay = new ol.Overlay({
            element: popupElement,
            positioning: 'bottom-center',
            offset: [0, -10],
            stopEvent: true,
            autoPan: { animation: { duration: 250 } }
        });
        map.addOverlay(popupOverlay);

        const hoverTooltipElement = document.createElement('div');
        hoverTooltipElement.className = 'map-tooltip hidden text-xs';
        const hoverTooltipOverlay = new ol.Overlay({
            element: hoverTooltipElement,
            positioning: 'bottom-center',
            offset: [0, -12],
            stopEvent: false
        });
        map.addOverlay(hoverTooltipOverlay);

        // Storytelling Label Overlay
        const storyLabelElement = document.createElement('div');
        storyLabelElement.id = 'story-label';
        storyLabelElement.className = 'text-white font-bold pointer-events-none hidden';
        document.body.appendChild(storyLabelElement);

        const storyLabelOverlay = new ol.Overlay({
            element: storyLabelElement,
            positioning: 'bottom-center',
            offset: [0, -10], // Position closer above the marker
            stopEvent: false
        });
        map.addOverlay(storyLabelOverlay);

        const cungSonLabelElement = document.createElement('div');
        cungSonLabelElement.id = 'cungson-label';
        cungSonLabelElement.className = 'text-white font-bold pointer-events-none hidden';
        document.body.appendChild(cungSonLabelElement);
        const cungSonLabelOverlay = new ol.Overlay({
            element: cungSonLabelElement,
            positioning: 'bottom-center',
            offset: [0, -10],
            stopEvent: false
        });
        map.addOverlay(cungSonLabelOverlay);

        function showHoverTooltip(html, coordinate) {
            hoverTooltipElement.innerHTML = html;
            hoverTooltipElement.classList.remove('hidden');
            hoverTooltipOverlay.setPosition(coordinate);
        }

        function hideHoverTooltip() {
            hoverTooltipOverlay.setPosition(undefined);
            hoverTooltipElement.classList.add('hidden');
        }

        map.on('singleclick', (evt) => {
            const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
            if (!feature) { 
                popupOverlay.setPosition(undefined); 
                popupElement.dataset.type = '';
                popupElement.dataset.id = '';
                popupElement.dataset.coord = '';
                return; 
            }
            if (feature.get('stationType')) openStationPopup(feature, evt.coordinate);
            else if (feature.get('_type') === 'ward') openWardPopup(feature.get('_uniqueId'), evt.coordinate);
        });

        map.on('pointermove', (evt) => {
            if (evt.dragging) return;
            const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
            const targetEl = map.getTargetElement();
            if (targetEl) targetEl.style.cursor = feature ? 'pointer' : '';
            let tooltipHandled = false;

            if (feature && feature.get('_type') === 'ward') {
                const uniqueId = feature.get('_uniqueId');
                const val = state.mode === 'daily'
                    ? state.dataMap[state.endIndex]?.[uniqueId] || 0
                    : Math.max(0, (state.accumulatedMap[state.endIndex]?.[uniqueId] || 0) - (state.accumulatedMap[state.startIndex - 1]?.[uniqueId] || 0));
                updateLegendHover(val);
                showHoverTooltip(buildWardTooltipContent(uniqueId, val), evt.coordinate);
                tooltipHandled = true;
            } else {
                updateLegendHover(null);
            }

            if (!tooltipHandled && feature && feature.get('stationType')) {
                const sid = feature.get('stationId');
                const record = state.waterLevelMap[state.endIndex]?.[sid];
                showHoverTooltip(buildStationTooltipContent(feature, record), evt.coordinate);
                tooltipHandled = true;
            }

            if (!tooltipHandled) hideHoverTooltip();
        });

        const mapViewport = map.getViewport();
        if (mapViewport) {
            mapViewport.addEventListener('mouseleave', () => {
                hideHoverTooltip();
                updateLegendHover(null);
                const targetEl = map.getTargetElement();
                if (targetEl) targetEl.style.cursor = '';
            });
        }

        function showPopup(contentEl, coordinate) {
            popupElement.innerHTML = '';
            popupElement.appendChild(contentEl);
            popupOverlay.setPosition(coordinate);
        }

        function buildWardTooltipContent(uniqueId, value) {
            const name = state.wardNames[uniqueId] || 'Khu vực';
            const province = state.wardProvinces[uniqueId];
            const val = Number.isFinite(value) ? `${value.toFixed(1)} mm` : 'Không có số liệu mưa';
            const modeLabel = state.mode === 'daily' ? 'Mưa theo giờ' : 'Mưa tích lũy';
            const provinceLine = province ? `<div class="value">${province}</div>` : '';
            return `<div class="label">${name}</div>${provinceLine}<div class="value">${modeLabel}: ${val}</div>`;
        }

        function buildStationTooltipContent(feature, record) {
            const stationName = feature.get('stationLabel') || 'Trạm';
            const basin = feature.get('riverName');
            const type = feature.get('stationType');
            let valueLine = 'Chưa có dữ liệu mới';
            if (type === 'lake') {
                if (Number.isFinite(record?.ratio)) valueLine = `Đầy: ${record.ratio.toFixed(1)}%`;
                else if (Number.isFinite(record?.capacity)) valueLine = `Dung tích: ${record.capacity}`;
            } else if (Number.isFinite(record?.value)) {
                valueLine = `Mực nước: ${record.value.toFixed(2)} m`;
            }
            const status = type === 'lake' ? getLakeStatus(record || {}) : getRiverStatus(record || {});
            const statusLine = status?.label ? `<div class="value">${status.label}</div>` : '';
            const basinLine = basin ? `<div class="value">Sông ${basin}</div>` : '';
            return `<div class="label">${stationName}</div>${basinLine}<div class="value">${valueLine}</div>${statusLine}`;
        }

        // =============================================================================
        // 4. UTILITY FUNCTIONS
        // =============================================================================
        const normalizeProvince = (name) => {
            if (!name) return null;
            return name.trim().toLowerCase().replace(/^tỉnh\s+/, '').replace(/^tp\.?\s*/, '').replace(/^thành phố\s+/, '');
        };
        const allowedProvinceSet = new Set(ALLOWED_PROVINCES.map(normalizeProvince));
        const isAllowedProvince = (name) => {
            const normalized = normalizeProvince(name);
            return normalized ? allowedProvinceSet.has(normalized) : false;
        };
        const provinceFromWardId = (wardId) => {
            if (!wardId || typeof wardId !== "string") return null;
            const chunk = wardId.split("|")[0];
            return chunk ? normalizeProvince(chunk) : null;
        };
        function inferStationType(typeStr) {
            if (!typeStr) return 'river';
            const normalized = typeStr.toLowerCase();
            if (normalized.includes('lake') || normalized.includes('hồ') || normalized.includes('ho')) return 'lake';
            return 'river';
        }
        function normalizeTrendLabel(text) {
            if (!text) return '';
            return text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/đ/g, 'd').trim();
        }
        function normalizeSimple(text) {
            return (text || '').toString().trim().toLowerCase();
        }
        function applyOpacity(color, opacity) {
            const c = d3.color(color);
            if (!c) return color;
            c.opacity = (c.opacity || 1) * opacity;
            return c.formatRgb();
        }
        function matchesRiverFilter(name) {
            if (!filters.rivers || filters.rivers.size === 0) return true;
            const norm = normalizeSimple(name);
            if (!norm) return false;
            return Array.from(filters.rivers).some(r => normalizeSimple(r) === norm);
        }
        function getWarningLabel(value) {
            if (!Number.isFinite(value)) return 'Bình thường';
            if (value >= 3) return 'Trên BĐ3';
            if (value >= 2) return 'Trên BĐ2';
            if (value >= 1) return 'Trên BĐ1';
            return 'Dưới BĐ1';
        }
        function formatDateTick(dateStr) {
            try {
                const d = new Date(dateStr);
                if (isNaN(d.getTime())) return dateStr;
                return `${d.getDate()}/${d.getMonth() + 1}`;
            } catch(e) { return dateStr; }
        }
        function formatDisplayDate(dateStr) {
            try {
                const d = new Date(dateStr);
                if (isNaN(d.getTime())) return dateStr;
                return `${d.getHours()}h ${d.getDate()}/${d.getMonth() + 1}`;
            } catch(e) { return dateStr; }
        }
        function normalizeToHourKey(value) {
            if (!value) return null;
            const match = String(value).trim().match(/^(\d{4}-\d{2}-\d{2})[T ](\d{1,2}):/);
            if (!match) return null;
            const [, datePart, hourPart] = match;
            return `${datePart} ${hourPart.padStart(2, '0')}:00`;
        }
        function getLakeStatus(record) {
            const ratio = Number.isFinite(record?.ratio) ? record.ratio : 0;
            if (ratio > 105) return { label: "Tỷ lệ dung tích >105%", color: COLORS.purple };
            if (ratio > 100) return { label: "Tỷ lệ dung tích >100%", color: COLORS.red };
            if (ratio >= 95) return { label: "Tỷ lệ dung tích ≥95%", color: COLORS.yellow };
            if (ratio >= 90) return { label: "Tỷ lệ dung tích ≥90%", color: COLORS.green };
            return { label: "Tỷ lệ dung tích <90%", color: COLORS.blue };
        }
        function getRiverStatus(record) {
            const val = Number.isFinite(record?.value) ? record.value : null;
            const historic = Number.isFinite(record?.historic) ? record.historic : null;
            const bd3 = Number.isFinite(record?.bd3) ? record.bd3 : null;
            const bd2 = Number.isFinite(record?.bd2) ? record.bd2 : null;
            const warn = Number.isFinite(record?.warningValue) ? record.warningValue : 0;
            if (val !== null && historic !== null && val > historic) return { label: "Trên lũ lịch sử", color: COLORS.purple };
            if (val !== null && bd3 !== null && val > bd3) return { label: "Trên BĐ3", color: COLORS.red };
            if (val !== null && bd2 !== null && val > bd2) return { label: "Trên BĐ2", color: COLORS.yellow };
            if (warn >= 1 || (val !== null && bd2 !== null && val > bd2 * 0.9)) return { label: "Trên BĐ1", color: COLORS.green };
            return { label: "Dưới BĐ1", color: COLORS.blue };
        }
        const toMapCoord = (lat, lon) => ol.proj.fromLonLat([lon, lat]);
        const fitPadding = () => isMobileView() ? [40, 20, 40, 20] : [50, 50, 50, 450];
        function computeLakeHalfSize(capacity) {
            const cap = Number.isFinite(capacity) ? capacity : 100000;
            const base = Math.sqrt(Math.max(cap, 1));
            return Math.min(0.02, Math.max(0.001, 0.0004 + base * 0.000003));
        }
        function computeLakePixelRadius(capacity, ratio = 0) {
            const baseHalf = computeLakeHalfSize(capacity);
            const capScale = Math.min(18, Math.max(6, 6 + baseHalf * 2500));
            const ratioBoost = 1 + Math.min(0.8, ratio / 150);
            return capScale * ratioBoost;
        }
        const styleLabelChip = (el, color = '#0ea5e9') => {
            el.style.color = '#fff';
            el.style.background = applyOpacity(color, 0.22);
            el.style.border = `1px solid ${applyOpacity(color, 0.5)}`;
            el.style.padding = '4px 10px';
            el.style.borderRadius = '9999px';
            el.style.boxShadow = '0 4px 12px rgba(0,0,0,0.45)';
        };
        const renderLegend = () => {
            if (DOM.legendGradient) {
                DOM.legendGradient.style.background = 'linear-gradient(90deg, #0ea5e9, #22c55e, #f59e0b, #ef4444)';
            }
            if (DOM.legendModeLabel) DOM.legendModeLabel.textContent = state.mode === 'daily' ? 'Theo giờ' : 'Tích lũy';
            if (DOM.legendMinVal) DOM.legendMinVal.textContent = 'Thấp';
            if (DOM.legendMaxVal) DOM.legendMaxVal.textContent = 'Cao';
            if (DOM.legendLakes) {
                const ranges = [
                    { label: ">105%", color: COLORS.purple },
                    { label: "100-105%", color: COLORS.red },
                    { label: "95-100%", color: COLORS.yellow },
                    { label: "90-95%", color: COLORS.green },
                    { label: "<90%", color: COLORS.blue }
                ];
                const triangle = (color) => `<span class="inline-flex w-0 h-0 border-l-[6px] border-r-[6px] border-l-transparent border-r-transparent border-t-[10px]" style="border-top-color:${color}"></span>`;
                DOM.legendLakes.innerHTML = `
                    <div class="text-[10px] uppercase tracking-wider text-gray-400 mb-1">Dung tích hồ chứa</div>
                    <div class="flex flex-col gap-1 text-xs">
                        ${ranges.map(r => `<div class="flex items-center gap-2">${triangle(r.color)}<span>${r.label}</span></div>`).join('')}
                    </div>`;
            }
            if (DOM.legendStations) DOM.legendStations.innerHTML = `
                <div class="text-[10px] uppercase tracking-wider text-gray-400 mb-1">Trạm mực nước sông</div>
                <div class="flex flex-col gap-1 text-xs">
                    <div class="flex items-center gap-2"><span class="inline-flex w-3 h-3 rounded-full" style="background:${COLORS.purple}"></span><span>Trên lũ lịch sử</span></div>
                    <div class="flex items-center gap-2"><span class="inline-flex w-3 h-3 rounded-full" style="background:${COLORS.red}"></span><span>Trên BĐ3</span></div>
                    <div class="flex items-center gap-2"><span class="inline-flex w-3 h-3 rounded-full" style="background:${COLORS.yellow}"></span><span>Trên BĐ2</span></div>
                    <div class="flex items-center gap-2"><span class="inline-flex w-3 h-3 rounded-full" style="background:${COLORS.green}"></span><span>Trên BĐ1</span></div>
                    <div class="flex items-center gap-2"><span class="inline-flex w-3 h-3 rounded-full" style="background:${COLORS.blue}"></span><span>Dưới BĐ1</span></div>
                </div>`;
        };
        const stopSliderAnimation = () => {
            if (sliderAnimationFrame !== null) {
                cancelAnimationFrame(sliderAnimationFrame);
                sliderAnimationFrame = null;
            }
        };
        const requestViewUpdate = () => {
            if (pendingUpdate !== null) return;
            pendingUpdate = requestAnimationFrame(() => { pendingUpdate = null; updateView(); });
        };

        // =============================================================================
        // 5. DATA LOADING & PROCESSING
        // =============================================================================
        async function initData() {
            try {
                // Mocking data URLs for standalone file. In production, these should be real paths.
                // NOTE: Replace these with your actual data paths or data objects
                const [geoRes, riverRes, rainRes, waterRes] = await Promise.allSettled([
                    d3.json("./geo/WardBoundary.geojson"),
                    d3.json("./geo/river.json"),
                    d3.csv("./data/rain.csv"), 
                    d3.csv("./data/river.csv")
                ]);

                if (geoRes.status === 'fulfilled') {
                    console.log("Core Data Loaded.");
                    processData(
                        geoRes.value,
                        riverRes.status === 'fulfilled' ? riverRes.value : null,
                        rainRes.status === 'fulfilled' ? rainRes.value : [],
                        waterRes.status === 'fulfilled' ? waterRes.value : []
                    );
                } else { 
                    throw new Error("GeoJSON missing"); 
                }
            } catch (e) {
                console.error("Load Error:", e);
            }
        }

        function processData(geo, river, rainCsv, waterCsv) {
            const filteredFeatures = geo.features.filter(f => isAllowedProvince(f.properties["Tỉnh thành mới"]));
            state.geoData = { ...geo, features: filteredFeatures };
            state.riverData = river;

            const cleanKey = key => (typeof key === "string" ? key.replace(/^\uFEFF/, '') : key);
            const pickField = (obj, candidates) => {
                if (!obj) return null;
                const keys = Object.keys(obj);
                for (const candidate of candidates) {
                    const match = keys.find(key => cleanKey(key) === candidate);
                    if (match) return match;
                }
                return null;
            };
            
            const sampleRain = rainCsv[0] || {}, sampleWater = waterCsv[0] || {};
            const keys = {
                rainDate: pickField(sampleRain, ["timestamp", "time", "date", "Thời gian", "Thời gian (UTC)"]),
                rainWard: pickField(sampleRain, ["ward_id", "commune_id_2cap", "wardid"]),
                rainVal: pickField(sampleRain, ["rain_mm_idw", "rain", "value"]),
                waterDate: pickField(sampleWater, ["timestamp", "Thời gian (UTC)", "time", "date"]),
                waterId: pickField(sampleWater, ["station_id", "Mã trạm/LakeCode", "stationid"]),
                waterVal: pickField(sampleWater, ["val", "value", "water_level", "Mực nước (m)"]),
                waterProv: pickField(sampleWater, ["Tên tỉnh", "province", "provinceName"]),
                waterRiver: pickField(sampleWater, ["Tên sông/Lưu vực", "river", "basin", "Tên sông", "luu_vuc", "basin_name"]),
                waterType: pickField(sampleWater, ["type"]),
                waterRatio: pickField(sampleWater, ["Tỷ lệ dung tích (%)", "Ty le dung tich (%)"]),
                waterCap: pickField(sampleWater, ["Dung tích TK (m3)", "Dung tích (m3)"]),
                waterTrend: pickField(sampleWater, ["Cảnh báo/Xu thế", "Canh bao/Xu the"]),
                waterWarnVal: pickField(sampleWater, ["Cảnh báo value (0-4)", "Canh bao value (0-4)"]),
                qIn: pickField(sampleWater, ["Q đến (m3/s)", "Q den (m3/s)"]),
                qOut: pickField(sampleWater, ["Q xả (m3/s)", "Q xa (m3/s)"]),
                bd1: pickField(sampleWater, ["BĐ1 (m)", "BD1 (m)"]),
                bd2: pickField(sampleWater, ["BĐ2 (m)", "BD2 (m)"]),
                bd3: pickField(sampleWater, ["BĐ3 (m)", "BD3 (m)"]),
                historic: pickField(sampleWater, ["Mực nước lịch sử (m)", "Muc nuoc lich su (m)"])
            };

            state.wardIds = [];
            filteredFeatures.forEach(f => {
                let id = f.properties["ward_id"];
                const name = f.properties["Phường xã mới"];
                const province = f.properties["Tỉnh thành mới"];
                if (!id) id = (province && name) ? `${province} | ${name}` : name;
                f.properties._uniqueId = id; 
                if (!state.wardIds.includes(id)) state.wardIds.push(id);
                state.wardNames[id] = name;
                state.wardProvinces[id] = province || '';
            });

            const dateSet = new Set();
            const addDate = (d, key, prov) => {
                const normalized = normalizeToHourKey(d[key]);
                if (normalized && (!prov || isAllowedProvince(prov))) dateSet.add(normalized);
            };
            rainCsv.forEach(d => addDate(d, keys.rainDate, provinceFromWardId(d[keys.rainWard])));
            waterCsv.forEach(d => addDate(d, keys.waterDate, d[keys.waterProv]));
            
            let allDates = Array.from(dateSet).sort((a,b) => new Date(a) - new Date(b));
            
            state.dates = allDates.filter(d => {
                const dateObj = new Date(d);
                return dateObj >= FILTER_RANGE.start && dateObj <= FILTER_RANGE.end;
            });

            state.visibleStartIndex = 0;

            state.dataMap = {}; state.accumulatedMap = {}; state.waterLevelMap = {}; 
            let runningTotals = {};
            state.wardIds.forEach(id => { runningTotals[id] = 0; state.wardTimeSeries[id] = []; });

            const rainByDate = d3.group(rainCsv, d => normalizeToHourKey(d[keys.rainDate]));
            const waterByDate = d3.group(waterCsv, d => normalizeToHourKey(d[keys.waterDate]));
            const lastWaterValues = {};

            state.dates.forEach((date, t) => {
                state.dataMap[t] = {}; state.accumulatedMap[t] = {}; state.waterLevelMap[t] = {}; 

                // Rain
                const rainRows = rainByDate.get(date) || [];
                let dailySum = 0, dailyCount = 0, dailyMax = 0;
                const rainLookup = new Map();
                
                rainRows.forEach(r => {
                    const rid = keys.rainWard ? r[keys.rainWard] : r["ward_id"];
                    if (!rid) return;
                    const prov = provinceFromWardId(rid);
                    if (prov && !isAllowedProvince(prov)) return;
                    rainLookup.set(rid, parseFloat(r[keys.rainVal] || 0));
                });

                state.wardIds.forEach(id => {
                    let val = rainLookup.has(id) ? rainLookup.get(id) : 0; 
                    if (isNaN(val)) val = 0;
                    state.wardTimeSeries[id].push({ date: date, val: val });
                    
                    if (rainLookup.has(id)) {
                        state.dataMap[t][id] = val;
                        runningTotals[id] += val;
                        dailySum += val; dailyCount++;
                        if(val > dailyMax) dailyMax = val;
                    }
                    state.accumulatedMap[t][id] = runningTotals[id];
                });
                state.timelineStats.push({ date: date, avg: dailyCount > 0 ? dailySum / dailyCount : 0, max: dailyMax });

                // Water
                const waterRows = waterByDate.get(date) || [];
                waterRows.forEach(row => {
                    const sid = keys.waterId ? row[keys.waterId] : row.station_id;
                    if (!sid) return;
                    const prov = keys.waterProv ? row[keys.waterProv] : null;
                    if (prov && !isAllowedProvince(prov)) return;

                    if (!state.stationMeta[sid]) {
                        const riverName = keys.waterRiver ? (row[keys.waterRiver] || "").trim() : null;
                        state.stationMeta[sid] = {
                            station_id: sid,
                            lat: parseFloat(row.lat || row.latitude || row.y),
                            lon: parseFloat(row.lon || row.lng || row.x),
                            name: row["Trạm/Hồ"] || row.station_name || sid,
                            type: inferStationType(keys.waterType ? row[keys.waterType] : row.type),
                            provinceRaw: prov,
                            province: prov ? normalizeProvince(prov) : null,
                            river: riverName,
                            riverNorm: normalizeSimple(riverName),
                            designCapacity: keys.waterCap ? parseFloat(row[keys.waterCap]) : null
                        };
                    }

                    const record = {
                        value: parseFloat(row[keys.waterVal] || 0),
                        ratio: keys.waterRatio ? parseFloat(row[keys.waterRatio]) : null,
                        capacity: keys.waterCap ? parseFloat(row[keys.waterCap]) : null,
                        warningValue: keys.waterWarnVal ? parseFloat(row[keys.waterWarnVal]) : null,
                        warningTrend: keys.waterTrend ? row[keys.waterTrend] : null,
                        qIn: keys.qIn ? parseFloat(row[keys.qIn]) : null,
                        qOut: keys.qOut ? parseFloat(row[keys.qOut]) : null,
                        bd1: keys.bd1 ? parseFloat(row[keys.bd1]) : null,
                        bd2: keys.bd2 ? parseFloat(row[keys.bd2]) : null,
                        bd3: keys.bd3 ? parseFloat(row[keys.bd3]) : null,
                        historic: keys.historic ? parseFloat(row[keys.historic]) : null
                    };
                    
                    lastWaterValues[sid] = record;
                    state.waterLevelMap[t][sid] = record;
                });
                
                Object.entries(lastWaterValues).forEach(([sid, prev]) => {
                    if (!state.waterLevelMap[t][sid]) state.waterLevelMap[t][sid] = prev;
                });
            });

            initGeoLayer();
            initRiverLayer();
            initStationLayer();
            initTimelineChart();
            applyLayerVisibility();
            populateRiverFilter();

            const maxIdx = state.dates.length - 1;
            DOM.sliderStart.max = maxIdx; DOM.sliderStart.min = state.visibleStartIndex; DOM.sliderStart.value = state.visibleStartIndex;
            DOM.sliderEnd.max = maxIdx; DOM.sliderEnd.min = state.visibleStartIndex; DOM.sliderEnd.value = state.visibleStartIndex;
            state.startIndex = state.visibleStartIndex; state.endIndex = state.visibleStartIndex;
            
            generateTicks();
            renderLegend();
            updateView();
            // Start Scrollytelling Observation once data is ready
            initScrollyTelling();
        }

        // =============================================================================
        // 6. MAP LAYER LOGIC
        // =============================================================================
        function initGeoLayer() {
            if (geoLayer) map.removeLayer(geoLayer);
            const features = new ol.format.GeoJSON().readFeatures(state.geoData, { featureProjection: 'EPSG:3857' });
            features.forEach(f => f.set('_type', 'ward'));
            geoLayer = new ol.layer.Vector({
                source: new ol.source.Vector({ features }),
                style: wardStyleFunction,
                zIndex: 400
            });
            map.addLayer(geoLayer);
            populateProvinceFilter();
            populateRiverFilter();
        }

        const transparentWardStyle = new ol.style.Style({
            stroke: new ol.style.Stroke({ color: 'rgba(0,0,0,0)', width: 0 }),
            fill: new ol.style.Fill({ color: 'rgba(0,0,0,0)' })
        });

        function wardStyleFunction(feature) {
            const id = feature.get('_uniqueId');
            const prov = feature.get("Tỉnh thành mới");
            if (filters.provinces.size > 0 && prov && !Array.from(filters.provinces).some(p => normalizeProvince(p) === normalizeProvince(prov))) {
                return transparentWardStyle;
            }

            let val = 0;
            if (state.mode === 'daily') {
                val = state.dataMap[state.endIndex]?.[id] || 0;
            } else {
                const end = state.accumulatedMap[state.endIndex]?.[id] || 0;
                const start = (state.startIndex > 0) ? (state.accumulatedMap[state.startIndex - 1]?.[id] || 0) : 0;
                val = Math.max(0, end - start);
            }

            if (val === 0 && state.mode === 'daily') return transparentWardStyle;

            const color = getColor(val);
            const fillColor = color === 'transparent' ? 'rgba(0,0,0,0)' : applyOpacity(color, layerOpacity.rain);
            return new ol.style.Style({
                stroke: new ol.style.Stroke({ color: 'rgba(0,0,0,0)', width: 0 }),
                fill: new ol.style.Fill({ color: fillColor }),
            });
        }

        function initRiverLayer() {
            if (riverLayer) map.removeLayer(riverLayer);
            if (!state.riverData) return;
            const features = new ol.format.GeoJSON().readFeatures(state.riverData, { featureProjection: 'EPSG:3857' });
            const riverStroke = () => new ol.style.Style({ stroke: new ol.style.Stroke({ color: applyOpacity('#60a5fa', layerOpacity.hydro), width: 1.5, lineCap: 'round', lineJoin: 'round' }) });
            riverLayer = new ol.layer.Vector({
                source: new ol.source.Vector({ features }),
                style: (feature) => {
                    const basin = feature.get('Basin') || feature.get('name') || '';
                    if (!matchesRiverFilter(basin)) return null;
                    return riverStroke();
                },
                zIndex: 500
            });
            map.addLayer(riverLayer);
        }

        function initStationLayer() {
            if (stationLayer) map.removeLayer(stationLayer);
            if (lakeLayer) map.removeLayer(lakeLayer);

            const stationSource = new ol.source.Vector();
            const lakeSource = new ol.source.Vector();
            
            Object.values(state.stationMeta).forEach(meta => {
                if (!Number.isFinite(meta.lat) || !Number.isFinite(meta.lon)) return;

                if (!matchesRiverFilter(meta.riverNorm || meta.river)) return;
                
                const isLake = inferStationType(meta.type) === 'lake';
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(toMapCoord(meta.lat, meta.lon)),
                    stationId: meta.station_id,
                    stationType: isLake ? 'lake' : 'river',
                    stationLabel: meta.name,
                    riverName: meta.river || '',
                    designCapacity: meta.designCapacity || null,
                    baseLat: meta.lat,
                    baseLon: meta.lon
                });

                if (isLake) lakeSource.addFeature(feature);
                else stationSource.addFeature(feature);
            });

            if (stationSource.getFeatures().length) {
                stationLayer = new ol.layer.Vector({
                    source: stationSource,
                    style: stationStyleFunction,
                    zIndex: 650
                });
                map.addLayer(stationLayer);
            }
            if (lakeSource.getFeatures().length) {
                lakeLayer = new ol.layer.Vector({
                    source: lakeSource,
                    style: lakeStyleFunction,
                    zIndex: 650
                });
                map.addLayer(lakeLayer);
            }
        }

        const invisibleStyle = new ol.style.Style({});

        function stationStyleFunction(feature) {
            const sid = feature.get('stationId');
            const record = state.waterLevelMap[state.endIndex]?.[sid];
            if (!record) return invisibleStyle;
            const status = getRiverStatus(record);
            const c = applyOpacity(status.color, layerOpacity.hydro);
            return new ol.style.Style({
                image: new ol.style.Circle({
                    radius: Math.max(CIRCLE_MARKER_RADIUS, 3 + (record.warningValue || 0) * 2),
                    fill: new ol.style.Fill({ color: c }),
                    stroke: new ol.style.Stroke({ color: c, width: 1 })
                })
            });
        }

        function lakeStyleFunction(feature) {
            const sid = feature.get('stationId');
            const record = state.waterLevelMap[state.endIndex]?.[sid];
            if (!record) return invisibleStyle;
            const ratio = Number.isFinite(record.ratio) ? record.ratio : 0;
            const nameNorm = normalizeSimple(feature.get('stationLabel'));
            const isBaHa = nameNorm.includes('sông ba hạ');
            let color = getLakeStatus(record).color;
            let strokeColor = applyOpacity('#fff', layerOpacity.hydro);
            if (currentStoryStep === 1) {
                if (!isBaHa) {
                    color = applyOpacity('#6b7280', layerOpacity.hydro);
                    strokeColor = applyOpacity('#9ca3af', layerOpacity.hydro);
                }
            }
            const radius = computeLakePixelRadius(record.capacity, ratio);
            const c = applyOpacity(color, layerOpacity.hydro);
            return new ol.style.Style({
                image: new ol.style.RegularShape({
                    points: 3,
                    radius,
                    rotation: Math.PI,
                    fill: new ol.style.Fill({ color: c }),
                    stroke: new ol.style.Stroke({ color: strokeColor, width: 1 })
                })
            });
        }

        function updateView() {
            state.startIndex = parseInt(DOM.sliderStart.value);
            state.endIndex = parseInt(DOM.sliderEnd.value);
            
            if (state.startIndex < state.visibleStartIndex) { state.startIndex = state.visibleStartIndex; DOM.sliderStart.value = state.visibleStartIndex; }
            if (state.endIndex < state.visibleStartIndex) { state.endIndex = state.visibleStartIndex; DOM.sliderEnd.value = state.visibleStartIndex; }
            if (state.startIndex > state.endIndex) { state.startIndex = state.endIndex; DOM.sliderStart.value = state.startIndex; }

            const total = parseInt(DOM.sliderEnd.max);
            if (total > 0) {
                const leftP = (state.startIndex / total) * 100;
                const rightP = (state.endIndex / total) * 100;
                DOM.rangeFill.style.left = `${leftP}%`;
                DOM.rangeFill.style.width = `${rightP - leftP}%`;
            }
            const displayDateEl = document.getElementById('display-date');
            const dateStartDisplay = document.getElementById('start-date-display');
            const endDateStr = formatDisplayDate(state.dates[state.endIndex]);
            const startDateStr = formatDisplayDate(state.dates[state.startIndex]);
            const isAccumulated = state.mode === 'accumulated';
            const labelText = isAccumulated
                ? `${startDateStr} - ${endDateStr}`
                : `${endDateStr}`;
            displayDateEl.innerText = '';
            
            recomputeRainThresholds();
            if (geoLayer?.getSource()) geoLayer.getSource().changed();
            if (riverLayer?.getSource()) riverLayer.getSource().changed();
            if (stationLayer?.getSource()) stationLayer.getSource().changed();
            if (lakeLayer?.getSource()) lakeLayer.getSource().changed();
            if (state.timelineStats.length) initTimelineChart();
            updateChartCursor();
            renderPinnedCharts();
            refreshStoryLabels();
            renderLegend();
        }

        function recomputeRainThresholds() {
            const vals = [];
            geoLayer?.getSource()?.getFeatures().forEach(feature => {
                const id = feature.get('_uniqueId');
                let val = 0;
                if (state.mode === 'daily') val = state.dataMap[state.endIndex]?.[id] || 0;
                else {
                    const end = state.accumulatedMap[state.endIndex]?.[id] || 0;
                    const start = state.accumulatedMap[state.startIndex - 1]?.[id] || 0;
                    val = Math.max(0, end - start);
                }
                if (val > 0) vals.push(val);
            });
            if (!vals.length) { rainThresholds = { p50: 0, p90: 0, p99: 0 }; return; }
            vals.sort((a,b) => a-b);
            const pct = p => vals[Math.floor(p * (vals.length - 1))];
            rainThresholds = { p50: pct(0.5), p90: pct(0.9), p99: pct(0.99) };
        }

        function getColor(value) {
            if (value <= 0) return 'transparent';
            if (rainThresholds.p50 === 0) return '#0ea5e9';
            if (value < rainThresholds.p50) return '#0ea5e9';
            if (value < rainThresholds.p90) return '#22c55e';
            if (value < rainThresholds.p99) return '#f59e0b';
            return '#ef4444';
        }

        function updateLegendHover(value) {
            // Simplified for this view, logic exists if legend is visible
        }

        function applyLayerVisibility() {
            const toggle = (layer, visible) => { if (layer) layer.setVisible(!!visible); };
            toggle(geoLayer, layerVisibility.rain);
            toggle(riverLayer, layerVisibility.river);
            toggle(stationLayer, layerVisibility.stations);
            toggle(lakeLayer, layerVisibility.lakes);
        }

        // =============================================================================
        // 7. CHART & POPUP LOGIC (D3)
        // =============================================================================
        function initTimelineChart() {
            const container = document.getElementById('chart-container');
            const svg = d3.select("#timeline-chart");
            svg.selectAll("*").remove();
            const width = container.clientWidth, height = container.clientHeight;

            const labelEl = document.querySelector('.timeline-chart-label');
            timelineBaseIndex = state.visibleStartIndex;

            // Try to find Hồ Sông Ba Hạ station id (prefer pinned if available)
            const pinnedMatch = pinnedCharts.find(p => {
                const meta = state.stationMeta[p.id];
                return meta && normalizeSimple(meta.name || '').includes('song ba ha');
            });
            const songBaHa = pinnedMatch
                ? state.stationMeta[pinnedMatch.id]
                : Object.values(state.stationMeta).find(m => normalizeSimple(m.name || '').includes('song ba ha'));
            const fallbackSid = '7D5B7DB0-D64A-4A36-BD4E-54A95CA62E9D';
            const sid = songBaHa?.station_id || fallbackSid;
            
            const defs = svg.append("defs");
            const gradient = defs.append("linearGradient").attr("id", "chartGradient").attr("x1", "0").attr("y1", "0").attr("x2", "0").attr("y2", "1");
            gradient.append("stop").attr("offset", "0%").attr("stop-color", "#60a5fa").attr("stop-opacity", 0.8);
            gradient.append("stop").attr("offset", "100%").attr("stop-color", "#60a5fa").attr("stop-opacity", 0);

            let mode = 'flow';
            const data = state.dates.slice(state.visibleStartIndex).map((_, idx) => {
                const rec = state.waterLevelMap[state.visibleStartIndex + idx]?.[sid];
                return {
                    qIn: Number.isFinite(rec?.qIn) ? rec.qIn : null,
                    qOut: Number.isFinite(rec?.qOut) ? rec.qOut : null
                };
            });

            const yVals = data.flatMap(d => [d.qIn, d.qOut]).filter(Number.isFinite);
            const latestRecord = state.waterLevelMap[state.endIndex]?.[sid] || {};

            // Fallback to rain avg chart if no flow data at all
            if (!yVals.length) {
                mode = 'rain';
                const rainData = state.timelineStats.slice(state.visibleStartIndex);
                chartXScale = d3.scaleLinear().domain([0, Math.max(rainData.length - 1, 0)]).range([0, width]);
                chartYScale = d3.scaleLinear().domain([0, (d3.max(rainData, d => d.avg) || 10) * 1.2]).range([height, 5]);
                const area = d3.area().curve(d3.curveMonotoneX).x((d, i) => chartXScale(i)).y0(height).y1(d => chartYScale(d.avg));
                svg.append("path").datum(rainData).attr("class", "chart-area").attr("d", area);
            } else {
                chartXScale = d3.scaleLinear().domain([0, Math.max(data.length - 1, 0)]).range([0, width]);
                chartYScale = d3.scaleLinear().domain([0, (d3.max(yVals) || 10) * 1.2]).range([height, 5]);
                const lineIn = d3.line().defined(d => Number.isFinite(d.qIn)).x((d, i) => chartXScale(i)).y(d => chartYScale(d.qIn)).curve(d3.curveMonotoneX);
                const lineOut = d3.line().defined(d => Number.isFinite(d.qOut)).x((d, i) => chartXScale(i)).y(d => chartYScale(d.qOut)).curve(d3.curveMonotoneX);
                svg.append("path").datum(data).attr("fill", "none").attr("stroke", "#22c55e").attr("stroke-width", 2).attr("d", lineIn);
                svg.append("path").datum(data).attr("fill", "none").attr("stroke", "#ef4444").attr("stroke-width", 2).attr("d", lineOut);
            }

            if (labelEl) {
                labelEl.textContent = mode === 'flow' ? 'Lượng đến/xả của hồ Sông Ba Hạ' : 'Lượng mưa trung bình';
            }
            const ratioEl = document.getElementById('lake-ratio-label');
            if (ratioEl) {
                const latestRatio = Number.isFinite(latestRecord?.ratio) ? latestRecord.ratio : null;
                const status = getLakeStatus(latestRecord);
                const ratioText = Number.isFinite(latestRatio) ? `${latestRatio.toFixed(1)}%` : '—';
                ratioEl.textContent = `Đầy ${ratioText}`;
                ratioEl.style.color = status.color;
                ratioEl.style.backgroundColor = applyOpacity(status.color, 0.12);
                ratioEl.style.border = `1px solid ${applyOpacity(status.color, 0.35)}`;
                ratioEl.style.padding = '2px 6px';
                ratioEl.style.borderRadius = '9999px';
                ratioEl.style.display = 'inline-block';
            }
            
            svg.append("rect").attr("id", "chart-selection-rect").attr("class", "chart-selection-rect").attr("height", height).attr("y", 0);
            svg.append("line").attr("id", "chart-cursor-line").attr("class", "chart-cursor").attr("y1", 0).attr("y2", height);

            svg.on("click", (event) => {
                if (!chartXScale) return;
                const [x] = d3.pointer(event);
                const idx = state.visibleStartIndex + Math.round(chartXScale.invert(x));
                DOM.sliderEnd.value = idx;
                requestViewUpdate();
            });
            updateChartCursor();
        }

        function updateChartCursor() {
            if (!chartXScale) return;
            const relStart = Math.max(0, state.startIndex - state.visibleStartIndex);
            const relEnd = Math.max(0, state.endIndex - state.visibleStartIndex);
            const xStart = chartXScale(relStart);
            const xEnd = chartXScale(relEnd);
            
            d3.select("#chart-cursor-line").attr("x1", xEnd).attr("x2", xEnd);
            d3.select("#chart-selection-rect").attr("x", Math.min(xStart, xEnd)).attr("width", Math.max(2, xEnd - xStart));
            updatePopupCursorLines();
        }

        // Shared Line Chart Renderer for Popups
        function renderLineChart(target, seriesList, options = {}) {
            const mobile = isMobileView();
            const baseWidth = options.width || 260;
            const baseHeight = options.height || 140;
            const parentWidth = target.parentElement?.clientWidth || baseWidth;
            const width = mobile ? Math.max(160, parentWidth) : Math.max(baseWidth, parentWidth);
            const aspect = baseHeight / baseWidth;
            const height = mobile ? Math.max(80, width * aspect) : Math.max(baseHeight, Math.round(width * aspect * 0.5));
            target.style.width = '100%';
            const margin = { top: 10, right: 10, bottom: mobile ? 10 : 22, left: 32 };
            const innerW = width - margin.left - margin.right, innerH = height - margin.top - margin.bottom;
            target.style.position = 'relative';
            const svgRoot = d3.select(target).append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", `0 0 ${width} ${height}`)
                .style("width", "100%")
                .style("height", `${height}px`);
            const svg = svgRoot.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            const domainDates = state.dates.slice(state.visibleStartIndex);
            const x = d3.scalePoint().domain(domainDates).range([0, innerW]);
            
            const allVals = seriesList.flatMap(s => s.data.map(d => d.val)).filter(Number.isFinite);
            const annotationVals = (options.annotations || []).map(ann => ann.value).filter(Number.isFinite);
            const axisVals = allVals.concat(annotationVals);
            const minVal = axisVals.length ? d3.min(axisVals) : 0;
            const maxVal = axisVals.length ? d3.max(axisVals) : 1;
            const range = maxVal - minVal;
            const padding = range === 0 ? (Math.abs(maxVal) * 0.1 || 1) : range * 0.1;
            const domainLow = minVal - padding;
            const domainHigh = maxVal + padding;
            const y = d3.scaleLinear().domain([domainLow, domainHigh]).range([innerH, 0]);

            let selectionRect = null;
            if (options.selectionRange && domainDates.length) {
                const startIdx = Math.max(0, Math.min(domainDates.length - 1, options.selectionRange.start));
                const endIdx = Math.max(0, Math.min(domainDates.length - 1, options.selectionRange.end));
                const xStart = x(domainDates[Math.min(startIdx, endIdx)]);
                const xEnd = x(domainDates[Math.max(startIdx, endIdx)]);
                const widthSpan = Math.max(4, Math.abs(xEnd - xStart));
                selectionRect = svg.append("rect")
                    .attr("x", Math.min(xStart, xEnd))
                    .attr("y", 0)
                    .attr("width", widthSpan)
                    .attr("height", innerH)
                    .attr("fill", "#3b82f6")
                    .attr("opacity", 0.15);
            }

            const seriesLookups = seriesList.map(s => new Map(s.data.map(d => [d.date, d.val])));

            seriesList.forEach(s => {
                const line = d3.line().defined(d => Number.isFinite(d.val)).x(d => x(d.date)).y(d => y(d.val)).curve(d3.curveMonotoneX);
                svg.append("path").datum(s.data).attr("fill", "none").attr("stroke", s.color).attr("stroke-width", 2).attr("d", line);
            });

            if (options.annotations) {
                options.annotations.forEach(ann => {
                    if (!Number.isFinite(ann.value)) return;
                    const yPos = y(ann.value);
                    svg.append("line").attr("x1", 0).attr("x2", innerW).attr("y1", yPos).attr("y2", yPos).attr("stroke", ann.color).attr("stroke-dasharray", "4 2").attr("stroke-width", 1);
                    if (ann.label) {
                        svg.append("text").attr("x", innerW - 4).attr("y", yPos - 2).attr("text-anchor", "end").attr("fill", ann.color).attr("font-size", 9).text(ann.label);
                    }
                });
            }
            
            const xTicks = domainDates.length >= 3 
                ? [domainDates[0], domainDates[Math.floor(domainDates.length / 2)], domainDates[domainDates.length - 1]]
                : domainDates;
            if (!mobile) {
                svg.append("g").attr("class", "popup-chart axis").attr("transform", `translate(0,${innerH})`)
                    .call(d3.axisBottom(x).tickValues(xTicks).tickFormat(formatDateTick))
                    .selectAll("path, line").attr("stroke-width", 0.5);
            }
            const formatYAxis = (val) => {
                if (Math.abs(val) >= 1000) return `${(val / 1000).toFixed(1)}k`;
                return val;
            };
            svg.append("g").attr("class", "popup-chart axis")
                .call(d3.axisLeft(y).ticks(3).tickFormat(formatYAxis))
                .selectAll("path, line").attr("stroke-width", 0.5);

            if (options.legend) {
                const legend = svg.append("g").attr("transform", `translate(0,${-4})`);
                options.legend.forEach((item, idx) => {
                    const g = legend.append("g").attr("transform", `translate(${idx * 90},0)`);
                    g.append("rect").attr("x", 0).attr("y", 0).attr("width", 10).attr("height", 10).attr("fill", item.color);
                    g.append("text").attr("x", 14).attr("y", 9).attr("fill", "#ccc").attr("font-size", 9).text(item.label);
                });
            }

            if (options.yLabel) {
                svg.append("text").attr("transform", `translate(${-28},${innerH / 2}) rotate(-90)`).attr("fill", "#999").attr("font-size", 9).attr("text-anchor", "middle").text(options.yLabel);
            }
            
            // Cursor Line
            if (Number.isFinite(options.cursorIndex) && domainDates.length) {
                const boundedIndex = Math.min(Math.max(0, options.cursorIndex), domainDates.length - 1);
                const cx = x(domainDates[boundedIndex]);
                if (cx !== undefined) {
                    const cursorLine = svg.append("line").attr("class", "popup-cursor-line").attr("x1", cx).attr("x2", cx).attr("y1", 0).attr("y2", innerH).attr("stroke", "#fbbf24").attr("stroke-dasharray", "4 2");
                    registerPopupCursor({ line: cursorLine, rect: selectionRect, scale: x, dates: domainDates });
                }
            }
        }

        function openWardPopup(id, coordinate) {
            const container = document.createElement('div'); container.className = "w-[260px] p-1";
            const provinceLabel = state.wardProvinces[id] ? `<div class="text-[11px] text-gray-400">${state.wardProvinces[id]}</div>` : '';
            container.innerHTML = `
                <div class="flex items-start justify-between mb-1">
                    <div>
                        <div class="font-bold text-sm mb-0 text-white">${state.wardNames[id] || id}</div>
                        ${provinceLabel}
                    </div>
                </div>
                <div class="border-b border-gray-700 my-2"></div>`;
            const chartDiv = document.createElement('div'); container.appendChild(chartDiv);

            const mapRef = state.mode === 'daily' ? state.dataMap : state.accumulatedMap;
            const data = [];
            for (let i = state.visibleStartIndex; i < state.dates.length; i++) {
                const raw = mapRef[i]?.[id];
                const val = Number(raw) || 0;
                data.push({ date: state.dates[i], val });
            }
            
            if (data.length) {
                const label = state.mode === 'daily' ? 'Mưa' : 'Mưa tích lũy';
                renderLineChart(chartDiv, [{ data, color: "#38bdf8", label }], { cursorIndex: state.endIndex - state.visibleStartIndex, selectionRange: { start: state.startIndex - state.visibleStartIndex, end: state.endIndex - state.visibleStartIndex } });
            }
            else chartDiv.innerText = "Không có dữ liệu";
            popupElement.dataset.type = 'ward';
            popupElement.dataset.id = id;
            popupElement.dataset.coord = JSON.stringify(coordinate);
            showPopup(container, coordinate);
        }

        function openStationPopup(feature, coordinate) {
            const sid = feature.get('stationId');
            const meta = state.stationMeta[sid] || {};
            const basin = meta.river || feature.get('riverName') || '—';
            const prov = meta.provinceRaw || meta.province || '—';
            const container = document.createElement('div'); container.className = "w-[280px] p-1";
            const warnRecord = state.waterLevelMap[state.endIndex]?.[sid];
            const warnStatus = meta.type === 'lake' ? null : getRiverStatus(warnRecord);
            const lakeStatus = meta.type === 'lake' ? getLakeStatus(warnRecord) : null;
            const warnText = meta.type === 'lake' ? `Đầy ${Number.isFinite(warnRecord?.ratio) ? warnRecord.ratio.toFixed(1) + '%' : '—'}` : (warnStatus?.label || getWarningLabel(warnRecord?.warningValue));
            const warnColor = meta.type === 'lake' ? (lakeStatus?.color || COLORS.blue) : (warnStatus?.color || COLORS.blue);
            
            container.innerHTML = `
                <div class="flex items-start justify-between mb-2">
                    <div>
                        <div class="font-bold text-sm text-white">${feature.get('stationLabel')}</div>
                        <div class="text-[11px] text-gray-400">Sông ${basin}, tỉnh ${prov}</div>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                        <span class="px-2 py-1 rounded text-[11px] font-semibold" style="background:${warnColor}22;color:${warnColor};border:1px solid ${warnColor}55;">${warnText}</span>
                    </div>
                </div>
                <div class="border-b border-gray-700 mb-2"></div>`;
            const chartDiv = document.createElement('div'); container.appendChild(chartDiv);
            
            const build = (fn) => {
                const res = [];
                for (let i = state.visibleStartIndex; i < state.dates.length; i++) {
                    const val = fn(state.waterLevelMap[i]?.[sid]);
                    if (Number.isFinite(val)) res.push({ date: state.dates[i], val });
                }
                return res;
            };

            if (feature.get('stationType') === 'lake') {
                const qIn = build(r => r?.qIn);
                const qOut = build(r => r?.qOut);
                const storage = build(r => {
                    const ratio = Number.isFinite(r?.ratio) ? r.ratio : null;
                    const cap = Number.isFinite(r?.capacity) ? r.capacity : (feature.get('designCapacity') || state.stationMeta[sid]?.designCapacity);
                    if (ratio === null || !Number.isFinite(cap)) return null;
                    return (ratio / 100) * cap;
                });
                const annCap = [];
                const capVal = feature.get('designCapacity') || state.stationMeta[sid]?.designCapacity || null;
                if (Number.isFinite(capVal)) annCap.push({ value: capVal, color: COLORS.red});

                renderLineChart(
                    chartDiv,
                    [{data:storage, color:"#38bdf8", label: "Dung tích"}],
                    { 
                        height: 100,
                        annotations: annCap,
                        cursorIndex: state.endIndex - state.visibleStartIndex,
                        selectionRange: { start: state.startIndex - state.visibleStartIndex, end: state.endIndex - state.visibleStartIndex },
                        legend: [{ label: "Dung tích", color: "#38bdf8" }, { label: "DT thiết kế (triệu m³)", color: COLORS.red }]
                    }
                );
                const flowDiv = document.createElement('div'); container.appendChild(flowDiv);
                renderLineChart(
                    flowDiv,
                    [
                        {data:qIn, color:"#22c55e", label:"Lượng đến"},
                        {data:qOut, color:"#ef4444", label:"Lượng xả"}
                    ],
                    { 
                        height: 100,
                        cursorIndex: state.endIndex - state.visibleStartIndex,
                        selectionRange: { start: state.startIndex - state.visibleStartIndex, end: state.endIndex - state.visibleStartIndex },
                        legend: [{ label: "Lượng đến", color: "#22c55e" }, { label: "Lượng xả (m³/s)", color: "#ef4444" }],
                    }
                );
            } else {
                const level = build(r => r?.value);
                const cur = state.waterLevelMap[state.endIndex]?.[sid];
                const anns = [];
                if (cur?.bd1) anns.push({ value: cur.bd1, color: COLORS.green });
                if (cur?.bd2) anns.push({ value: cur.bd2, color: COLORS.yellow });
                if (cur?.bd3) anns.push({ value: cur.bd3, color: COLORS.red });
                if (cur?.historic) anns.push({ value: cur.historic, color: COLORS.purple });
                renderLineChart(
                    chartDiv,
                    [{data:level, color:"#38bdf8", label:"Mực nước"}],
                    { 
                        height: 150,
                        annotations: anns,
                        cursorIndex: state.endIndex - state.visibleStartIndex,
                        selectionRange: { start: state.startIndex - state.visibleStartIndex, end: state.endIndex - state.visibleStartIndex },
                        legend: [{ label: "Mực nước (m)", color: "#38bdf8" }],
                    }
                );
            }
            popupElement.dataset.type = 'station';
            popupElement.dataset.id = sid;
            popupElement.dataset.coord = JSON.stringify(coordinate);
            showPopup(container, coordinate);
        }

        function setPinnedStations(stationsToPin) {
            // Pinned charts disabled
            popupOverlay.setPosition(undefined);
            pinnedCharts = [];
            renderPinnedCharts();
        }

        function renderPinnedCharts() {
            // Clear charts and do nothing (pinned charts removed)
            document.querySelectorAll('.step-pinned-charts').forEach(el => el.innerHTML = '');
            renderMobilePinnedPreview();
        }

        function buildWardChartConfig(id) {
            if (!state.dates.length) return null;
            const mapRef = state.mode === 'daily' ? state.dataMap : state.accumulatedMap;
            const data = [];
            for (let i = state.visibleStartIndex; i < state.dates.length; i++) {
                const raw = mapRef[i]?.[id];
                const val = Number(raw);
                if (!Number.isFinite(val)) continue;
                data.push({ date: state.dates[i], val });
            }
            if (!data.length) return null;
            const relStart = Math.max(0, state.startIndex - state.visibleStartIndex);
            const relEnd = Math.max(0, state.endIndex - state.visibleStartIndex);
            const label = state.mode === 'daily' ? 'Mưa' : 'Mưa tích lũy';
            return {
                series: [{ data, color: "#38bdf8", label }],
                options: {
                    height: 140, // Keep height
                    width: 250,
                    cursorIndex: relEnd,
                    selectionRange: { start: relStart, end: relEnd }
                }
            };
        }

        function buildWardPinnedCharts(id) {
            const config = buildWardChartConfig(id);
            return config ? [config] : [];
        }

        function buildStationSeries(sid, getter) {
            const series = [];
            for (let i = state.visibleStartIndex; i < state.dates.length; i++) {
                const rec = state.waterLevelMap[i]?.[sid];
                if (!rec) continue;
                const val = getter(rec);
                if (!Number.isFinite(val)) continue;
                series.push({ date: state.dates[i], val });
            }
            return series;
        }

        function buildLakePinnedCharts(meta, sid, subtype = 'storage') {
            const relStart = Math.max(0, state.startIndex - state.visibleStartIndex);
            const relEnd = Math.max(0, state.endIndex - state.visibleStartIndex);
            const charts = [];
            if (subtype === 'storage') {
                const storageSeries = buildStationSeries(sid, rec => {
                    const ratio = Number(rec?.ratio);
                    if (!Number.isFinite(ratio)) return null;
                    const cap = Number(rec?.capacity) || Number(meta.designCapacity);
                    if (Number.isFinite(cap)) return (ratio / 100) * cap;
                    return ratio;
                });
                if (storageSeries.length) {
                    const capVal = Number(meta.designCapacity);
                    const annotations = [];
                    if (Number.isFinite(capVal)) annotations.push({ value: capVal, color: COLORS.red });
                    charts.push({
                        series: [{ data: storageSeries, color: "#38bdf8", label: "Dung tích" }],
                        options: {
                            height: 120, /* Increased from 100 */
                            width: 300, /* Slightly narrower */
                            annotations,
                            cursorIndex: relEnd,
                            selectionRange: { start: relStart, end: relEnd },
                            legend: [{ label: "Dung tích", color: "#38bdf8" }, ...(Number.isFinite(capVal) ? [{ label: "DT thiết kế (triệu m³)", color: COLORS.red }] : [])]
                        }
                    });
                }
            } else if (subtype === 'flow') {
                const qInSeries = buildStationSeries(sid, rec => Number(rec?.qIn));
                const qOutSeries = buildStationSeries(sid, rec => Number(rec?.qOut));
                if (qInSeries.length || qOutSeries.length) {
                    charts.push({
                        series: [
                            { data: qInSeries, color: "#22c55e", label: "Lượng đến" },
                            { data: qOutSeries, color: "#ef4444", label: "Lượng xả" }
                        ],
                        options: {
                            height: 120, /* Increased from 100 */
                            width: 300, /* Slightly narrower */
                            cursorIndex: relEnd,
                            selectionRange: { start: relStart, end: relEnd },
                            legend: [{ label: "Lượng đến", color: "#22c55e" }, { label: "Lượng xả", color: "#ef4444" }]
                        }
                    });
                }
            }
            return charts;
        }

        function buildRiverPinnedCharts(meta, sid) {
            const relStart = Math.max(0, state.startIndex - state.visibleStartIndex);
            const relEnd = Math.max(0, state.endIndex - state.visibleStartIndex);
            const levelSeries = buildStationSeries(sid, rec => Number(rec?.value));
            if (!levelSeries.length) return [];
            const options = {
                height: 120, /* Align height with lake charts */
                width: 300,
                cursorIndex: relEnd,
                selectionRange: { start: relStart, end: relEnd },
                legend: [{ label: "Mực nước", color: "#38bdf8" }],
                yLabel: 'm'
            };
            const cur = state.waterLevelMap[state.endIndex]?.[sid];
            const annotations = [];
            if (Number.isFinite(cur?.bd1)) annotations.push({ value: cur.bd1, color: COLORS.green });
            if (Number.isFinite(cur?.bd2)) annotations.push({ value: cur.bd2, color: COLORS.yellow });
            if (Number.isFinite(cur?.bd3)) annotations.push({ value: cur.bd3, color: COLORS.red });
            if (Number.isFinite(cur?.historic)) annotations.push({ value: cur.historic, color: COLORS.purple });
            if (annotations.length) options.annotations = annotations;
            return [{ series: [{ data: levelSeries, color: "#38bdf8", label: "Mực nước" }], options }];
        }

        function buildStationPinnedCharts(sid, subtype = null) {
            if (!state.dates.length) return [];
            const meta = state.stationMeta[sid];
            if (!meta) return [];
            return inferStationType(meta.type) === 'lake' 
                ? buildLakePinnedCharts(meta, sid, subtype || 'storage')
                : buildRiverPinnedCharts(meta, sid);
        }

        function renderMobilePinnedPreview() {
            if (!DOM.mobilePinnedPreview) return;
            const wrapper = document.querySelector('.timeline-wrapper');
            const panel = wrapper?.querySelector('.glass-panel');
            DOM.mobilePinnedPreview.innerHTML = '';

            // Keep timeline visible; we no longer hide the wrapper
            if (wrapper) {
                wrapper.style.display = 'flex';
                wrapper.style.pointerEvents = 'none';
                wrapper.classList.remove('show-mobile-pins');
            }
            if (panel) panel.querySelectorAll(':scope > *').forEach(el => { el.style.display = ''; });
        }

        // =============================================================================
        // 8. UI EVENT HANDLERS
        // =============================================================================
        function generateTicks() {
            const container = document.getElementById('timeline-ticks');
            container.innerHTML = '';
            const step = Math.ceil(state.dates.length / 5);
            state.dates.forEach((d, i) => { 
                if (i % step === 0 || i === state.dates.length - 1) { 
                    const div = document.createElement('div'); div.innerText = formatDateTick(d); container.appendChild(div); 
                }
            });
        }

        function populateProvinceFilter() {
            const list = document.getElementById('filter-province-list');
            if(list) list.innerHTML = ''; 
        }

        function populateRiverFilter() {
            const list = document.getElementById('filter-river-list');
            if(list) list.innerHTML = '';
            const rivers = new Set();
            Object.values(state.stationMeta).forEach(meta => { if (meta.river) rivers.add(meta.river); });
            (state.riverData?.features || []).forEach(f => {
                const basin = f.properties?.Basin;
                if (basin) rivers.add(basin);
            });
            Array.from(rivers).sort().forEach(r => {
                const wrapper = document.createElement('label'); wrapper.className = "flex items-center gap-2 text-white text-xs";
                const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = r; cb.className = "accent-blue-500";
                if (filters.rivers.has(r)) cb.checked = true;
                wrapper.appendChild(cb); wrapper.appendChild(document.createTextNode(r));
                if(list) list.appendChild(wrapper);
            });
        }

        DOM.sliderStart.addEventListener('input', () => { 
            stopSliderAnimation();
            if(parseInt(DOM.sliderStart.value) > parseInt(DOM.sliderEnd.value)) DOM.sliderEnd.value = DOM.sliderStart.value; 
            requestViewUpdate(); 
        });
        DOM.sliderEnd.addEventListener('input', () => { 
            stopSliderAnimation();
            if(parseInt(DOM.sliderEnd.value) < parseInt(DOM.sliderStart.value)) DOM.sliderStart.value = DOM.sliderEnd.value; 
            requestViewUpdate(); 
        });

        window.addEventListener('resize', () => { 
            if(state.timelineStats.length) initTimelineChart();
            renderMobilePinnedPreview();
        });

        const bindOpacity = (el, key) => {
            if (!el) return;
            el.addEventListener('input', () => { layerOpacity[key] = parseInt(el.value, 10) / 100; updateView(); });
        };
        bindOpacity(DOM.opacityRain, 'rain');
        bindOpacity(DOM.opacityHydro, 'hydro');
        const toggleLegend = (force) => {
            if (!DOM.legendPanel) return;
            const shouldShow = (force === undefined) ? DOM.legendPanel.classList.contains('hidden') : force;
            if (shouldShow) DOM.legendPanel.classList.remove('hidden');
            else DOM.legendPanel.classList.add('hidden');
        };
        if (DOM.legendToggleBtn && DOM.legendPanel) {
            DOM.legendToggleBtn.addEventListener('click', () => toggleLegend());
        }
        if (DOM.legendCloseBtn && DOM.legendPanel) {
            DOM.legendCloseBtn.addEventListener('click', () => toggleLegend(false));
        }
        
        // =============================================================================
        // 9. SCROLLYTELLING LOGIC
        // =============================================================================
        
        function initScrollyTelling() {
            const observerOptions = {
                root: document.getElementById('story-container'),
                rootMargin: '-40% 0px -40% 0px', // Trigger when element is in middle 20% of screen
                threshold: 0
            };
            const scroller = observerOptions.root;

            const observer = new IntersectionObserver((entries) => {
                let anyStepActive = false;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        anyStepActive = true;
                        const stepIndex = entry.target.dataset.step;
                        
                        // Highlight active text
                        document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
                        entry.target.classList.add('active');
                        currentStoryStep = parseInt(stepIndex, 10);
                        if (scroller) stepScrollAnchors[currentStoryStep] = scroller.scrollTop;
                        requestViewUpdate();

                        if (stepIndex === "1") activateStep1();
                        if (stepIndex === "2") activateStep2();
                        if (stepIndex === "3") activateStep3();
                        if (stepIndex === "4") activateStep4();
                        if (stepIndex === "5") activateStep5();
                        if (stepIndex === "6") activateStep6();
                        if (stepIndex === "7") activateStep7();
                    } else {
                        entry.target.classList.remove('active');
                    }
                });
                if (!anyStepActive && isMobileView()) {
                    document.querySelector('.timeline-wrapper')?.classList.remove('show-mobile-pins');
                }
                if (anyStepActive) updateTimelineFromScroll();
            }, observerOptions);

            document.querySelectorAll('.step').forEach(step => observer.observe(step));
            if (scroller) scroller.addEventListener('scroll', handleStoryScroll, { passive: true });
            
            // Initial call
            setTimeout(() => {
                if(document.querySelector('.step[data-step="1"]')) {
                    currentStoryStep = 1;
                    activateStep1();
                }
            }, 500);
        }

        // --- Helper to find Date Index (Approximate match) ---
        function findDateIndex(dateString) {
            // dateString format expected: "YYYY-MM-DD HH:mm" or "YYYY-MM-DDTHH:mm:00"
            if (!state.dates.length) return 0;
            const target = new Date(dateString).getTime();
            let closestIdx = 0;
            let minDiff = Infinity;
            
            state.dates.forEach((d, i) => {
                const diff = Math.abs(new Date(d).getTime() - target);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            });
            return closestIdx;
        }

        const clamp01 = (v) => Math.min(1, Math.max(0, v));
        function animateTimelineRange(startIdx, endIdx, duration = 2800) {
            stopSliderAnimation();
            const minIdx = parseInt(DOM.sliderStart.min || 0, 10);
            const maxIdx = parseInt(DOM.sliderStart.max || state.dates.length - 1, 10);
            const clampedStart = Math.min(maxIdx, Math.max(minIdx, startIdx));
            const clampedEnd = Math.min(maxIdx, Math.max(minIdx, endIdx));

            DOM.sliderStart.value = clampedStart;
            DOM.sliderEnd.value = clampedStart;
            requestViewUpdate();
            if (clampedStart === clampedEnd) return;

            const distance = clampedEnd - clampedStart;
            const animStart = performance.now();
            let lastValue = clampedStart;
            const easeInOut = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

            const stepAnim = (now) => {
                const progress = Math.min(1, (now - animStart) / duration);
                const eased = easeInOut(progress);
                const nextVal = Math.round(clampedStart + distance * eased);
                if (nextVal !== lastValue) {
                    DOM.sliderEnd.value = nextVal;
                    lastValue = nextVal;
                    requestViewUpdate();
                }
                if (progress < 1) {
                    sliderAnimationFrame = requestAnimationFrame(stepAnim);
                } else {
                    sliderAnimationFrame = null;
                }
            };
            sliderAnimationFrame = requestAnimationFrame(stepAnim);
        }

        function setTimeline(startStr, endStr, options = {}) {
            const duration = options.duration || 3200;
            const animate = options.animate === true;
            const sIdx = findDateIndex(startStr);
            const eIdx = findDateIndex(endStr);
            const stepKey = options.step || currentStoryStep || null;
            const snapToStart = options.snapToStart !== false;

            if (stepKey) stepRanges[stepKey] = { start: sIdx, end: eIdx };

            if (!animate) {
                stopSliderAnimation();
                DOM.sliderStart.value = sIdx;
                DOM.sliderEnd.value = snapToStart ? sIdx : eIdx;
                requestViewUpdate();
                return;
            }
            
            animateTimelineRange(sIdx, eIdx, duration);
        }

        function updateTimelineFromScroll() {
            const scroller = document.getElementById('story-container');
            const activeStep = document.querySelector('.step.active');
            if (!scroller || !activeStep) return;
            const stepNum = parseInt(activeStep.dataset.step, 10);
            const range = stepRanges[stepNum];
            if (!range) return;

            const stepTop = activeStep.offsetTop;
            const stepHeight = activeStep.offsetHeight || 1;
            const viewportH = scroller.clientHeight || 1;
            const scrollTop = scroller.scrollTop;
            // Start tracking as soon as the step activates; finish when it leaves the top.
            // Compute a per-pixel jump so time = (scroll delta) * (timeSpan / scrollSpan).
            const startAt = stepTop; // no buffer so timeline starts immediately
            const endAt = stepTop + stepHeight;
            const scrollSpan = Math.max(32, endAt - startAt); // avoid tiny spans
            const timeSpan = Math.max(1, range.end - range.start);
            const speedBoost = 1.35; // push timeline further per scroll
            const anchor = stepScrollAnchors[stepNum] ?? startAt;
            const effectiveStart = anchor; // start exactly where the step was activated
            const effectiveSpan = Math.max(32, endAt - effectiveStart);
            const deltaScroll = Math.max(0, scrollTop - effectiveStart) * speedBoost;
            const clampedProgress = clamp01(deltaScroll / effectiveSpan);
            const nextIdx = range.start + Math.round(timeSpan * clampedProgress);

            if (parseInt(DOM.sliderEnd.value, 10) !== nextIdx || parseInt(DOM.sliderStart.value, 10) !== range.start) {
                DOM.sliderStart.value = range.start;
                DOM.sliderEnd.value = nextIdx;
                requestViewUpdate();
            }
        }

        function handleStoryScroll() {
            if (scrollSyncPending) return;
            scrollSyncPending = true;
            requestAnimationFrame(() => {
                scrollSyncPending = false;
                updateTimelineFromScroll();
            });
        }

        const lonLatBoxToExtent = (box) => {
            if (!Array.isArray(box) || box.length !== 4) return null;
            const [minLon, minLat, maxLon, maxLat] = box.map(Number);
            const bl = ol.proj.fromLonLat([minLon, minLat]);
            const tr = ol.proj.fromLonLat([maxLon, maxLat]);
            return ol.extent.boundingExtent([bl, tr]);
        };
        const bufferExtent = (extent, meters = 0) => {
            if (!extent) return null;
            return ol.extent.buffer(extent, meters);
        };
        function fitToStoryBounds(key, fallbackExtent, options = {}) {
            const cfg = STORY_BOUNDS[key];
            const padding = options.padding || cfg?.padding || fitPadding();
            const duration = options.duration || cfg?.duration || 900;
            let extent = cfg?.extentLonLat ? lonLatBoxToExtent(cfg.extentLonLat) : null;
            if (!extent && typeof fallbackExtent === 'function') extent = fallbackExtent();
            else if (!extent) extent = fallbackExtent;
            if (!extent || ol.extent.isEmpty(extent)) return;
            map.getView().fit(extent, { padding, duration });
        }
        function getRiverExtent(riverName) {
            // Find extent of all stations/river features matching name
            let extent = ol.extent.createEmpty();
            let found = false;

            if (stationLayer) {
                stationLayer.getSource().getFeatures().forEach(f => {
                     const fRiver = f.get('riverName');
                     if (fRiver && normalizeSimple(fRiver).includes(normalizeSimple(riverName))) {
                         ol.extent.extend(extent, f.getGeometry().getExtent());
                         found = true;
                     }
                });
            }
            if (lakeLayer) {
                lakeLayer.getSource().getFeatures().forEach(f => {
                     const fRiver = f.get('riverName');
                     if (fRiver && normalizeSimple(fRiver).includes(normalizeSimple(riverName))) {
                         ol.extent.extend(extent, f.getGeometry().getExtent());
                         found = true;
                     }
                });
            }
            // Fallback to river layer geometries
            if (riverLayer) {
                riverLayer.getSource().getFeatures().forEach(f => {
                    const basin = f.get('Basin') || f.get('name');
                    if (basin && normalizeSimple(basin).includes(normalizeSimple(riverName))) {
                        ol.extent.extend(extent, f.getGeometry().getExtent());
                        found = true;
                    }
                });
            }

            if (found && !ol.extent.isEmpty(extent)) {
                return extent;
            }
            return null;
        }
        function getStationExtent(nameStr, bufferMeters = 10000) {
            const search = normalizeSimple(nameStr);
            const collectExtent = (layer) => {
                if (!layer) return null;
                let target = null;
                layer.getSource().getFeatures().forEach(f => {
                    const label = normalizeSimple(f.get('stationLabel'));
                    if (label.includes(search)) target = f;
                });
                if (!target) return null;
                const coords = target.getGeometry().getCoordinates();
                const baseExtent = ol.extent.boundingExtent([coords, coords]);
                return bufferExtent(baseExtent, bufferMeters);
            };
            return collectExtent(lakeLayer) || collectExtent(stationLayer);
        }

        function zoomToRiver(riverName, boundsKey = null, options = {}) {
            const fallback = () => getRiverExtent(riverName);
            if (boundsKey) fitToStoryBounds(boundsKey, fallback, options);
            else {
                const ext = fallback();
                if (ext) map.getView().fit(ext, { padding: fitPadding(), duration: 1000 });
            }
        }

        function openSpecificPopup(nameStr) {
            // Find feature by name
            let targetFeature = null;
            const search = normalizeSimple(nameStr);
            
            const check = (layer) => {
                if(!layer) return;
                layer.getSource().getFeatures().forEach(f => {
                    const label = normalizeSimple(f.get('stationLabel'));
                    if (label.includes(search)) targetFeature = f;
                });
            }
            
            check(lakeLayer);
            if(!targetFeature) check(stationLayer);

            if (targetFeature) {
                const coords = targetFeature.getGeometry().getCoordinates();
                openStationPopup(targetFeature, coords);
                // Center map on popup slightly offset to right to avoid sidebar
                const view = map.getView();
                view.animate({ center: coords, duration: 800 });
            }
        }

        function showSongBaHaLabel() {
            if (currentStoryStep === 4) {
                storyLabelElement.classList.add('hidden');
                storyLabelOverlay.setPosition(undefined);
                return;
            }
            if (lakeLayer) {
                const songBaHaFeature = lakeLayer.getSource().getFeatures().find(f => normalizeSimple(f.get('stationLabel')).includes('sông ba hạ'));
                if (songBaHaFeature) {
                    const coords = songBaHaFeature.getGeometry().getCoordinates();
                    storyLabelElement.innerText = 'Hồ Sông Ba Hạ';
                    styleLabelChip(storyLabelElement, COLORS.blue);
                    storyLabelOverlay.setPosition(coords);
                    storyLabelElement.classList.remove('hidden');
                    return;
                }
            }
            storyLabelElement.classList.add('hidden');
        }

        function showCungSonLabel(force = false) {
            if (!force && ![2,3,5,6].includes(currentStoryStep)) return hideCungSonLabel();
            if (!stationLayer) return hideCungSonLabel();
            const feature = stationLayer.getSource().getFeatures().find(f => normalizeSimple(f.get('stationLabel')).includes('củng sơn'));
            if (!feature) return hideCungSonLabel();
            const sid = feature.get('stationId');
            const record = state.waterLevelMap[state.endIndex]?.[sid];
            const status = getRiverStatus(record);
            const warnText = status?.label || 'Mực nước';

            const coords = feature.getGeometry().getCoordinates();
            cungSonLabelElement.innerText = `Trạm Củng Sơn - ${warnText}`;
            styleLabelChip(cungSonLabelElement, status?.color || COLORS.blue);
            cungSonLabelOverlay.setPosition(coords);
            cungSonLabelElement.classList.remove('hidden');
        }

        function refreshStoryLabels() {
            showSongBaHaLabel();
            showCungSonLabel();
        }

        // --- STEP 1 LOGIC ---
        function activateStep1() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 1;
            // Time: 0h 15/11/2025
            setTimeline("2025-11-14T01:00:00", "2025-11-14T20:00:00", { step: 1, animate: false });

            // Layer visible: Lakes, Rivers
            layerVisibility = { rain: false, river: true, stations: false, lakes: true };
            applyLayerVisibility();

            // Filter: Sông Ba
            filters.rivers.clear();
            filters.rivers.add("Ba");
            filters.provinces.clear();
            
            // Re-init layers to apply filter
            initRiverLayer(); 
            initStationLayer();
            applyLayerVisibility();

            // Zoom fit Sông Ba
            zoomToRiver("Ba", "baBasin");

            // Pin Station: Hồ Sông Ba Hạ (Flow) to show chart on first slide
            setPinnedStations([{ name: "Sông Ba Hạ", subtype: "flow" }]);

            showSongBaHaLabel();
            hideCungSonLabel();

            renderPinnedCharts();
        }

        // --- STEP 2 LOGIC ---
        function activateStep2() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 2;
            // Time: 20h 14/11 - 10h 16/11
            setTimeline("2025-11-14T20:00:00", "2025-11-16T10:00:00", { step: 2, animate: false });

            // Layer visible: Lakes, Rivers (Keep same as step 1 usually, or ensure)
            layerVisibility = { rain: false, river: true, stations: true, lakes: true };
            applyLayerVisibility();

            // Filter: Sông Ba (Ensure maintained)
            if (!filters.rivers.has("Ba")) {
                filters.rivers.clear();
                filters.rivers.add("Ba");
                initRiverLayer(); 
                initStationLayer();
            }

            // Pin Station: Hồ Sông Ba Hạ (Flow)
            setPinnedStations([{ name: "Sông Ba Hạ", subtype: "flow" }]);

            fitToStoryBounds("songBaHaTight", () => getStationExtent("Sông Ba Hạ", 22000));
            showSongBaHaLabel();
            showCungSonLabel();
        }

        // --- STEP 3 LOGIC ---
        function activateStep3() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 3;
            // Time: 10h 16/11 - 19h 18/11
            setTimeline("2025-11-16T10:00:00", "2025-11-18T19:00:00", { step: 3, animate: false });

            // Layer visible: Lakes, Rivers
            layerVisibility = { rain: false, river: true, stations: true, lakes: true };
            applyLayerVisibility();

            // Filter: Sông Ba (Ensure maintained)
            if (!filters.rivers.has("Ba")) {
                filters.rivers.clear();
                filters.rivers.add("Ba");
                initRiverLayer(); 
                initStationLayer();
            }

            // Pin Station: Hồ Sông Ba Hạ (Flow)
            setPinnedStations([{ name: "Sông Ba Hạ", subtype: "flow" }]);

            fitToStoryBounds("songBaHaTight", () => getStationExtent("Sông Ba Hạ", 9000));
            showSongBaHaLabel();
            showCungSonLabel();
        }

        // --- STEP 4 LOGIC ---
        function activateStep4() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 4;
            state.mode = 'accumulated'; // highlight rain tích lũy over full region
            // Time: 19h 18/11 - 9h 19/11
            setTimeline("2025-11-18T19:00:00", "2025-11-19T09:00:00", { step: 4, animate: false });

            // Layer visible: Rain, Lakes, Rivers, Stations
            layerVisibility = { rain: true, river: true, stations: true, lakes: true };
            applyLayerVisibility();

            // Filters: whole region rain, keep only Sông Ba hydro network
            filters.rivers.clear();
            filters.provinces.clear();
            filters.rivers.add("Ba");
            initGeoLayer();
            initRiverLayer(); 
            initStationLayer();

            // Pin Stations: Củng Sơn & lưu lượng Hồ Sông Ba Hạ
            setPinnedStations([
                { name: "Củng Sơn" },
                { name: "Sông Ba Hạ", subtype: "flow" }
            ]);

            fitToStoryBounds("wholeRegion", () => bufferExtent(getRiverExtent("Ba"), 60000));
            showSongBaHaLabel();
            hideCungSonLabel();
        }

        // --- STEP 5 LOGIC ---
        function activateStep5() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 5;
            // Time: 9h 19/11 - 17h 19/11
            setTimeline("2025-11-19T09:00:00", "2025-11-19T17:00:00", { step: 5, animate: false });

            // Layer visible: hide rain, show hydro layers
            layerVisibility = { rain: false, river: true, stations: true, lakes: true };
            applyLayerVisibility();

            // Filter: Sông Ba
            filters.provinces.clear();
            if (!filters.rivers.has("Ba")) {
                filters.rivers.clear();
                filters.rivers.add("Ba");
                initRiverLayer(); 
                initStationLayer();
            }
            
            // Zoom and Popup
            fitToStoryBounds("songBaHaTight", () => getStationExtent("Sông Ba Hạ", 22000));
            setPinnedStations([
                { name: "Sông Ba Hạ", subtype: "storage" },
                { name: "Sông Ba Hạ", subtype: "flow" }
            ]);
            showSongBaHaLabel();
            showCungSonLabel();
        }

        // --- STEP 6 LOGIC ---
        function activateStep6() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 6;
            // Time: 20h 19/11 - 19h 20/11
            setTimeline("2025-11-19T20:00:00", "2025-11-20T19:00:00", { step: 6, animate: false });

            // Layer visible: Rain, Lakes, Rivers, Stations
            layerVisibility = { rain: true, river: true, stations: true, lakes: true };
            applyLayerVisibility();

            // Filter: Sông Ba
            filters.provinces.clear();
            if (!filters.rivers.has("Ba")) {
                filters.rivers.clear();
                filters.rivers.add("Ba");
                initRiverLayer(); 
                initStationLayer();
            }
            
            // Zoom and Popup
            fitToStoryBounds("songBaHaArea", () => getStationExtent("Sông Ba Hạ", 22000));
            setPinnedStations([
                { name: "Sông Ba Hạ", subtype: "storage" },
                { name: "Sông Ba Hạ", subtype: "flow" }
            ]);
            showSongBaHaLabel();
            showCungSonLabel();
        }

        // --- STEP 7 LOGIC ---
        function activateStep7() {
            popupOverlay.setPosition(undefined);
            currentStoryStep = 7;
            // Time: 1h 20/11 - 3h 20/11
            setTimeline("2025-11-20T01:00:00", "2025-11-20T03:00:00", { step: 7, animate: false });

            // Layer visible: Rain, Lakes, Rivers, Stations
            layerVisibility = { rain: true, river: true, stations: true, lakes: true };
            applyLayerVisibility();

            // Filter: Phú Yên province
            filters.rivers.clear();
            filters.provinces.clear();
            filters.provinces.add("Phú Yên");
            initGeoLayer();
            initRiverLayer(); 
            initStationLayer();

            // Zoom to province
            const provinceFeature = geoLayer.getSource().getFeatures().find(f => {
                const provName = f.get("Tỉnh thành mới");
                return provName && normalizeSimple(provName).includes('phú yên');
            });
            if (provinceFeature) {
                map.getView().fit(provinceFeature.getGeometry().getExtent(), { padding: fitPadding(), duration: 1000 });
            }

            // Pin Stations: Củng Sơn & Phú Lâm
            setPinnedStations([
                { name: "Củng Sơn" },
                { name: "Phú Lâm" }
            ]);

            fitToStoryBounds("songBaHaArea", () => getStationExtent("Sông Ba Hạ", 22000));
            showSongBaHaLabel();
            hideCungSonLabel();
        }

        // Start Application
        initData();
    </script>
</body>
</html>
